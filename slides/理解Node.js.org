#+AUTHOR: 唐新发
#+EMAIL: tangxinfa@xunlei.com
#+DESCRIPTION: 90 minutes
#+OPTIONS: toc:nil

* 大纲

  #+begin_html
  <div style="font-size:0.7em;">
  #+end_html
  - [[介绍]]

  - [[语言]]

  - [[安装]]

  - [[模块]]

  - [[包]]

  - [[运行机制]]

  - [[Http服务]]

  - [[基础Http服务框架：Connect]]

  - [[高级Http服务框架：Express]]
  #+begin_html
  </div>
  #+end_html

* 介绍

* LAMPP WEB架构
  
  #+ATTR_HTML: style="width:18em; margin-left:6em;"
  [[../static/lampp_arch.png]]

* Node.js WEB架构

  #+ATTR_HTML: style="width:18em; margin-left:6em;"
  [[../static/spool-full-javascript-stack.png]]

* Node.js组成
  
* 语言
* 安装
* 模块
* 包
* 运行机制
* Http服务
* 基础Http服务框架：Connect
* 高级Http服务框架：Express

* Javascript简介

  #+begin_quote
  web浏览器上的唯一语言\\
  \\
  批着c外衣的lisp\\
  \\
  被误解最多的语言
  #+end_quote
  \\
  \\
  #+begin_center
  #+begin_html
    <div style="font-size:0.7em;">
  #+end_html  
  #+begin_src html
    <button onClick='alert("Hello Javascript");'>Click Me</button>
  #+end_src
  \\
  #+begin_html
    <button onClick='alert("Hello Javascript");'>Click Me</button>
  #+end_html
  #+begin_html
    </div>
  #+end_html  
  #+end_center

* Javascript诞生

  　　1995年，Netscape（网景）打算在浏览器（Netscape Navigator 2.0）中嵌入Scheme，招募来Brendan Eich（布兰登·艾奇），事情很快变成在浏览器中嵌入一种像Java的脚本语言，Brendan Eich在10天的时间里写出了JavaScript的雏形Mocha（摩卡），Mocha也被用于嵌入Netscape的服务器产品LiveWire，为了便于市场营销Mocha改名为LiveScript，1995年底Netscape和Sun商谈后终将LiveScript更名为JavaScript。

* Javascript扩张
  
  　　JavaScript 1.0随Netscape Navigator 2.0发行并取得了成功，随后Netscape在Netscape Navigator 3.0中发布了JavaScript 1.1版，这个时候微软决定进军浏览器，发布了IE 3.0并搭载了一个JavaScript的克隆版，叫做JScript。

  　　1997年，JavaScript 1.1作为一个草案提交给欧洲计算机制造商协会（ECMA），完成了标准化（ECMA-262标准，ECMAScript脚本语言）。

  　　后来Netscape在浏览器大战中不敌微软，LiveWire服务器产品也跟着失败了，服务器端JavaScript消失了。

* Javascript统治
  
  #+begin_center
  #+Caption: Javascript驱动Web
  #+ATTR_HTML: style="width:25em;" title="javascript driver the web"
  [[../static/browsers.png]]  
  #+end_center

* Javascript标准

  ECMAScript 描述了以下内容：
    - 语法
    - 类型
    - 语句
    - 关键字
    - 保留字
    - 运算符
    - 对象

* Javascript的组成

  一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：
    - 核心（ECMAScript）
    - 文档对象模型（DOM）
    - 浏览器对象模型（BOM）

* Javascript特点

  #+begin_quote
  函数式\\
  \\
  原型继承\\
  \\
  弱类型\\
  \\
  词法作用域
  #+end_quote

* Javascript的类

  #+begin_quote
  Javascript是\\
  \\
  基于原型\\
  \\
  面向对象语言\\
  \\
  没有“类”概念\\
  \\
  \\
  原型＋构造函数＋new关键字＝类
  #+end_quote

* Javascript类示例

  #+ATTR_HTML: :textarea
  #+begin_src js -n
    function Man(name, age) {
        this.name = name;
        this.age  = age;
    }
    Man.prototype.introduce = function(){
        return this.name + " is " + this.age;
    };
    
    var man1 = new Man("jack", 24);
    var man2 = new Man("tom", 25);
    console.log(man1.introduce());
    console.log(man2.introduce());
  #+end_src
  \\
  #+begin_example
    jack is 24
    tom is 25
  #+end_example
      
* Javascript的闭包

  #+begin_quote
  闭包是\\
  =代码块= （通常是函数）\\
  和\\
  创建该代码块的上下文中 =数据= \\
  的 =结合= 。\\
  \\
  \\
  表现为\\
  函数可以访问外部作用域定义的变量\\
  即使外部作用域已经退出
  #+end_quote

* Javascript闭包示例

  #+begin_src js -n
    function Woman(name, age) {
        this.name = name;
        this.introduce = function(){
            return this.name + " is " + (age - 10);
        };
    }
    var woman1 = new Woman("mary", 34);
    var woman2 = new Woman("rose", 45);
    console.log(woman1.introduce());
    console.log(woman2.introduce());
  #+end_src
  \\
  #+begin_example
    mary is 24
    rose is 35
  #+end_example

* 常见的Web后端开发技术

  #+begin_center
  #+Caption: Perl
  #+ATTR_HTML: style="width:3em;" title="Perl"
  [[../static/perl.jpeg]]

  #+Caption: Php
  #+ATTR_HTML: style="width:3em;" title="Php"
  [[../static/php.jpeg]]

  #+Caption: Python
  #+ATTR_HTML: style="width:3em;" title="Python"
  [[../static/python.jpeg]]

  #+Caption: Ruby
  #+ATTR_HTML: style="width:3em;" title="Ruby"
  [[../static/ruby.jpeg]]
  #+end_center

  #+begin_center
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/apache.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/nginx.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/lighttpd.jpeg]]
  #+end_center
  \\
  #+begin_center
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mysql.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/postgres.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/oracle.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/memcache.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/redis.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mongodb.jpeg]]
  #+end_center

* 今天要介绍的Web后端开发技术

  #+begin_center
  #+ATTR_HTML: style="width:20.8em;" title="Node"
  [[../static/node.jpeg]]
  #+end_center
  \\
  \\
  \\
  #+begin_center
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mysql.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/postgres.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/oracle.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/memcache.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/redis.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mongodb.jpeg]]
  #+end_center

* Node.js简介
  
  #+begin_html
  <div class="leftinfo">
  #+end_html

  　　Node.js是在Chrome的Javascript引擎之上构建的一个平台，
  很容易用来构建 =高性能= 、 =可扩展= 的网络应用程序。

  　　Node.js是 =单线程= 基于 =事件驱动= 、 =非阻塞I/O模型= 从而表现得轻巧、高效，
  适用于开发 =数据密集型= 的 =实时响应= 分布式应用程序。

  #+begin_html
  </div>
  <div class="rightinfo">
  #+end_html

  #+ATTR_HTML: style="width:85%;"
  #+begin_center
  [[../static/node_arch.jpeg]]
  #+end_center

  #+begin_html
  </div>
  #+end_html

* Node.js简介

  Node.js =不是=
  #+begin_quote
  像php、python、perl、ruby这样的 =语言=\\
  \\
  像CakePHP、Django、Rails这样的服务器端 =框架=\\
  \\
  像JQuery、ExtJS、Backbone.js这样的浏览器端 =库=\\
  #+end_quote

* Node.js现状

  #+begin_html
  <div class="leftinfo">
  #+end_html

  活跃的社区

  #+ATTR_HTML: style="width:13em;" title="github最受欢迎的项目Top5"
  [[../static/github_starred_top5.png]]

  #+begin_html
  </div>
  #+end_html

  #+begin_html
  <div class="rightinfo">
  #+end_html

  丰富的模块

  #+ATTR_HTML: style="width:13em;"
  [[../static/npmjs_screenshot.png]]

  #+begin_html
  </div>
  #+end_html

* Node.js用户案例

  #+begin_html
    <center style="font-size:0.8em">
  #+end_html
  《[[http://www.csdn.net/article/2012-10-08/2810589-LinkedIn_Rails_to_Node][LinkedIn移动端用Node替代Rails：减少90%服务器 速度提升20倍]]》
  #+begin_html
    </center>
  #+end_html

  #+begin_html
  <div class="leftinfo">
  #+end_html
  #+ATTR_HTML: style="width:10em;"
  [[../static/linkedin.jpeg]]
  #+begin_quote
  在服务端\\
  我们的整个移动软件栈完全使用Node构建\\
  第一个原因是可扩展\\
  第二个原因是性能上的巨大提升
  #+end_quote
  #+begin_html
  </div>
  <div class="rightinfo" style="font-size:0.7em;">
  #+end_html
  Node.js的优势在于：\\
  - 更好的性能以及更少的内存占用，在某型情景下性能提升20倍
  - 程序员可以充分发挥他们JavaScript的技巧
  - 前端与后端开发人员可以在一个小组内协作
  - 服务器从30台减少到只有3台，硬件资源利用率提升10倍，并且还有提升的空间。
  - 开发工作可以更加专注在应用开发，而不是到处去救火
  #+begin_html
  </div>
  #+end_html

* Node.js安装
  
  #+begin_html
    <div class="leftinfo">
  #+end_html

  [[http://nodejs.org/download/]]

  #+ATTR_HTML: style="width:11em;"
  [[../static/node_download.png]]

  #+begin_html
    </div>
    <div class="rightinfo" style="font-size:0.7em;">
  #+end_html

  - /usr/local/bin/node :: 主程序
    
  - /usr/local/bin/npm :: 模块管理程序

  - /usr/local/lib/node\_modules :: 全局模块目录

  #+begin_html
    </div>
    <div style="clear:both;"></div>
  #+end_html

  #+begin_src sh
    wget http://nodejs.org/dist/v0.10.12/node-v0.10.12.tar.gz
    tar xzf node-v0.10.12.tar.gz
    ./configure
    make
    sudo make install
  #+end_src

  #+begin_example
    ~$ node -e 'console.log("hello node.js");'
    hello node.js
  #+end_example

* Node.js模块机制

  #+begin_html
    <div class="leftinfo">
  #+end_html

  #+begin_quote
  JavaScript没有模块系统\\
  所有js文件中定义的顶级对象名存在于同一个命名空间\\
  \\
  #+end_quote

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_quote
  - [[http://www.commonjs.org][CommonJS]]规范 :: 其目标是为了构建JavaScript在包括Web服务器，桌面，命令行工具，及浏览器方面的生态系统。
  #+end_quote

  #+begin_html
      </div>
      <div style="clear:both; padding:0;">
      </div>
      <div class="leftinfo" style="font-size:0.7em;">
  #+end_html

  [[http://wiki.commonjs.org/wiki/Modules/1.1][CommonJS模块规范]]：
  #+begin_src artist
    
    +-------------+
    | module.js --+->模块是普通的js文件
    |             |                    
    | +---------+ |
    | | require +-+->用于导入其它模块接口的函数
    | +---------+ |  
    | +---------+ |  
    | | exports +-+->用于导出接口的对象
    | +---------+ |  
    | +---------+ |  
    | | module  +-+->当前模块对象
    | +---------+ |  
    |    ...  ----+->其它用户定义对象为模块私有
    +-------------+
  #+end_src

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_quote
  在Node.js应用程序中\\
  首次require一个模块执行其代码\\
  返回其exports对象\\
  该exports对象会被Node.js缓存\\
  当再次require该模块直接返回缓存结果\\
  \\
  exports变量是module.exports对象的引用\\
  \\
  该模块不会对全局命名空间造成影响
  #+end_quote
  
  #+begin_html
    </div>
  #+end_html

* Node.js模块

  #+ATTR_HTML: class="codelink"
  [[../static/woman_module.js][woman\_module.js]]
#+INCLUDE: "../static/woman_module.js" src js -n

  #+ATTR_HTML: class="codelink"
  [[../static/woman_module.js][woman\_module\_usage.js]]
#+INCLUDE: "../static/woman_module_usage.js" src js -n

* Node.js类模块

  #+ATTR_HTML: class="codelink"
  [[../static/woman_module.js][woman\_class\_module.js]]
#+INCLUDE: "../static/woman_class_module.js" src js -n

  #+ATTR_HTML: class="codelink"
  [[../static/woman_module.js][woman\_class\_module\_usage.js]]
#+INCLUDE: "../static/woman_class_module_usage.js" src js -n

* Node.js包机制
  
  #+begin_html
    <div class="leftinfo" style="font-size:0.8em;">
  #+end_html

  #+begin_quote
  JavaScript没有包管理系统\\
  \\
  不能自动加载和安装依赖\\
  \\
  不利于开发大规模应用\\
  \\
  - [[http://wiki.commonjs.org/wiki/Packages/1.1][CommonJS包规范]] :: 存在 [[https://npmjs.org/doc/json.html][=package.json=]] 文件的目录即为包
  #+end_quote
  \\
  #+Caption: 重要字段说明
  #+ATTR_HTML: style="border:1px; font-size:0.6em;"
  | =name= [[(package_specs__name)]]                 | 包名                       |
  | =version= [[(package_specs__version)]]           | 版本号                     |
  | =main= [[(package_specs__main)]]                 | 当包被程序引用时需载入模块 |
  | =scripts= [[(package_specs__scripts)]]           | 用于包管理                 |
  | =dependencies= [[(package_specs__dependencies)]] | 依赖的其它包               |


  #+begin_html
    </div>
    <div class="rightinfo" style="font-size:0.5em;">
  #+end_html
  
  #+ATTR_HTML: class="codelink"
  [[/usr/local/lib/node_modules/npm/node_modules/tar/package.json][package.json]]
  #+begin_src js -n -r
    {
      "author": {
        "name": "Isaac Z. Schlueter",
        "email": "i@izs.me",
        "url": "http://blog.izs.me/"
      },
      "name": "tar",                                    (ref:package_specs__name)
      "description": "tar for node",
      "version": "0.1.17",                              (ref:package_specs__version)
      "repository": {
        "type": "git",
        "url": "git://github.com/isaacs/node-tar.git"
      },
      "main": "tar.js",                                 (ref:package_specs__main)
      "scripts": {                                      (ref:package_specs__scripts)
        "test": "tap test/*.js"
      },
      "dependencies": {                                 (ref:package_specs__dependencies)
        "inherits": "1.x",
        "block-stream": "*",
        "fstream": "~0.1.8"
      },
      "devDependencies": {
        "tap": "0.x",
        "rimraf": "1.x"
      },
      "license": "BSD",
      "readme": "...",
      "readmeFilename": "README.md",
      "_id": "tar@0.1.17",
      "dist": {
        "shasum": "408c8a95deb8e78a65b59b1a51a333183a32badc"
      },
      "_from": "tar@0.1.17",
      "_resolved": "https://registry.npmjs.org/tar/-/tar-0.1.17.tgz"
    }
  #+end_src

  #+begin_html
    </div>
  #+end_html

* Node.js包管理工具

  #+begin_html
    <style type="text/css">
      .npm-logo {
          margin-left: 1em;
      }
      .npm-logo p {
          margin:0;
      }
      .npm-logo img {
          width: 3em;
      }
      .npm-install-choose p {
          line-height: 1.5em;
      }
    </style>

    <div class="npm-logo">
  #+end_html

  [[../static/npm.png]]

  #+begin_html
    </div>
    <div class="leftinfo" style="font-size:0.5em; width:35%;">
  #+end_html

  - [[https://npmjs.org/][=npm=]] =install= <name>

    安装包到本地模块目录

    ./node\_modules

    附带的可执行程序将安装到

    ./node\_modules/.bin

  - [[https://npmjs.org/][=npm=]] =install -g= <name> 
    
    安装包到全局模块目录
  
    /usr/local/lib/node\_modules

    附带的可执行程序将安装到

    /usr/local/bin

  - [[https://npmjs.org/][=npm=]] =link=
  
    将当前包链接到全局模块目录下

  - [[https://npmjs.org/][=npm=]] =link= <name>
    
    将全局包链接到本地模块目录下

  #+begin_html
    </div>
    <div class="rightinfo npm-install-choose" style="font-size:0.5em; width:60%;">
  #+end_html
  - 什么时候安装到本地？

    当你想通过require("package")的方式使用你的包，则最好安装为本地，这样node.js可以更快找到包。

  - 什么时候安装到全局？

    如果安装的包附带有可执行程序，需要在命令行使用，最好安装为全局，这样可以直接在命令行访问。需要注意的是全局模块目录不在node.js的模块搜索范围内，需要链接到本地模块目录。

  - 什么时候链接到全局？

    当你在开发一个供其它项目使用的模块时，通过链接到全局方便其它项目使用。

  - 什么时候链接到本地？

    对于附带可执行程序又通过require("package")的方式使用的包，可先安装到全局，再链接到本地，在多个项目使用同一个包时特别便利。

  #+begin_html
  </div>
  #+end_html

* Node.js模块定位

  #+begin_html
    <div class="leftinfo" style="font-size:0.7em;">
  #+end_html

  =require(X)如何定位到模块文件？=

  - require("fs")
    
    直接加载核心模块

  - require("./X")
  - require("../X")
  - require("/X")

    指定路径加载模块

  - require("X")

    搜索路径加载模块

  #+begin_html
    </div>
    <div class="rightinfo" style="font-size:0.6em;">
  #+end_html
  
  - 指定路径加载模块
      - 指定路径下X文件
      - 指定路径下X.js文件
      - 指定路径下X.node文件
      - 指定路径下X/package.json文件中的main对应的文件
      - 指定路径下X/index.js
      - 指定路径下X/index.node

  - 搜索路径加载模块

    依次尝试以下路径进行模块加载

    - 当前目录下的node\_modules目录
    - 上一级目录下的node\_modules目录，直到根目录为止
    - NODE\_PATH环境变量指定的各个路径
    - 用户根目录下的.node\_modules目录
    - 用户根目录下的.node\_libraries目录
    - node.js安装目录前缀下的/lib/node
      
      通常为：/usr/local/lib/node

  #+begin_html
    </div>
  #+end_html
  
* Node.js高效的秘诀

  #+begin_html
    <style type="text/css" media="screen">
    .data-access-latency-table .right {
       border-left: 1px solid black;
       border-right: 1px solid black;
    }
    .data-access-latency-table td {
       padding:0 0.5em;
    }
    </style>   
    
  #+end_html

  #+CAPTION: I/O操作耗时对比
  #+ATTR_HTML: style="width:70%; margin:0 auto; border: 1px; padding:" class="data-access-latency-table"
  |----------+-----------+--------------|
  | I/O      | CPU Cycle | Type         |
  |----------+-----------+--------------|
  | L1-cache |         3 |              |
  | L2-cache |        14 | Non-blocking |
  | RAM      |       250 |              |
  |----------+-----------+--------------|
  | Disk     |  41000000 | Blocking     |
  | Network  | 240000000 |              |
  |----------+-----------+--------------|

  #+ATTR_HTML: style="float:left; margin-left:4em; width:5em;"
  [[../static/nonblocking.jpeg]]
  
  #+begin_quote
  \\
  Node.js是一个全新的开发平台\\
  \\
  所有会阻塞的api都以异步回调的方式进行封装\\
  \\
  #+end_quote

* Node.js层次化的世界

  #+ATTR_HTML: style="float:left; margin-left:3em; width:6.5em;"
  [[../static/modules.jpeg]]

  #+begin_quote
  \\
  node.js像积木一样灵活\\
  \\
  能够开发小到像telnet这样的网络客户端工具\\
  \\
  大到twitter这样的大规模分布式web服务\\
  \\
  #+end_quote

  #+begin_html
  <div style="background:url(../static/up.jpeg) no-repeat center center; background-size:contain;">
  #+end_html

  #+begin_quote
  \\
  \\
  [[http://expressjs.com][=express=]]

  [[https://github.com/senchalabs/connect][=connect=]]

  [[http://nodejs.org/api/http.html#http_http][=http=]]

  [[http://nodejs.org/api/net.html][=net=]]

  [[http://nodejs.org/api/dgram.html][=udp=]]\\
  \\
  #+end_quote
  
  #+begin_html
  </div>
  #+end_html

* Node.js构建Echo服务器

  #+ATTR_HTML: class="codelink"
  [[../static/echo_server.js][echo\_server.js]]
#+INCLUDE: "../static/echo_server.js" src js -n
  #+begin_html
  <div class="codeexplain"><a href="javascript: toggleNotesWindow();" target="_self">讲解</a></div>
  #+end_html

  #+begin_html
    <div class="leftinfo">
  #+end_html

  #+begin_example
  ~$ node ./echo_server.js
  Server running

  #+end_example

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_example
    ~$ telnet 127.0.0.1 8001
    hello
    hello
  #+end_example

  #+begin_html
    </div>
    <div style="clear:both;"></div>
  #+end_html

  #+begin_quote
  在Node.js中，除了代码，一切都是并行的！\\
  #+end_quote

  :NOTES:
  现在我们来逐行解释发生了什么：

  #+begin_src sh
    node ./echo_server.js
  #+end_src

  #+begin_quote
  node.js解释执行echo\_server.js，
  
  然后进入事件循环，

  如果没有事件需要处理则退出程序。
  \\
  \\
  #+end_quote

  #+begin_src js
  var net = require('net');
  #+end_src
  
  #+begin_quote
  导入 [[http://nodejs.org/api/net.html][net]] 模块，它是node.js自带的核心模块，对异步网络进行了封装。

  net模块的js代码将被执行，返回该模块导出的一些函数及“类”。
  \\
  \\
  #+end_quote

  #+begin_src js -n -r
    var server = net.createServer(             (ref:echo_server__createServer)
        function (socket) {                    (ref:echo_server__createServer_callback)
            socket.pipe(socket);               (ref:echo_server__createServer_pipe)
        }
    );
  #+end_src

  #+begin_quote
  [[(echo_server__createServer)]] net.createServer创建一个tcp服务器对象，参数为绑定到服务器 [[http://nodejs.org/api/net.html#net_event_connection][connection]] 事件的回调函数，当node.js成功接收到一个连接时，该回调函数将被调用。
  
  [[(echo_server__createServer_callback)]] 该回调函数的参数为新建立的tcp连接对象，它是一个 [[http://nodejs.org/api/net.html#net_class_net_socket][net.Socket]] 类实例，

  [[(echo_server__createServer_pipe)]] echo的实现使用了Socket.pipe方法，该方法来自Socket的父类，将当前对象读取到的数据转发到参数指定的目标对象。
  \\
  \\
  #+end_quote

  #+begin_src js
    server.listen(8001);
  #+end_src

  #+begin_quote
  TCP服务器在绑定在8001端口进行监听，这里省略了第二个参数 =host= （其默认值为 =INADDR_ANY= ），第三个参数 =backlog= (其默认值为 =511= )，第四个数 =callback= ，
  net.Server的 =listen= 方法也是非阻塞的，绑定成功会调用回调函数 =callback= ，失败会发出 =error= 事件，这里为了示例的简单性没有进行错误处理。
  \\
  \\
  #+end_quote

  #+begin_src js
      console.log("Server running");
  #+end_src

  #+begin_quote
  node.js引入了浏览器端JavasSript常见的一些功能。
  
  如：console对象，用于输出日志；setTimeout函数，用于延迟执行。

  但浏览器上特有东西在node.js中是不存在的，如：window全局对象的，在node.js中对应的是 =global= 全局对象。
  \\
  \\
  #+end_quote

  js文件解释执行完毕，接下来就由node.js的事件循环接管了， node.js等待事件发生，然后调用事件关联的回调函数，应用程序的逻辑会在事件回调中得以执行。

  :END:

* Node.js构建Http服务

  #+ATTR_HTML: class="codelink"
  [[../static/web_server.js][web\_server.js]]
#+INCLUDE: "../static/web_server.js" src js -n
  #+begin_html
  <div class="codeexplain"><a href="javascript: toggleNotesWindow();" target="_self">讲解</a></div>
  #+end_html

  #+begin_html
  <div style="font-size:0.9em;">
  #+end_html
  #+begin_example -n
    ~$ curl -i http://localhost:8002
    HTTP/1.1 200 OK
    Content-Type: text/plain
    Date: Fri, 12 Jul 2013 08:28:42 GMT
    Connection: keep-alive
    Transfer-Encoding: chunked
    
    hello node.js
  #+end_example
  #+begin_html
  </div>
  #+end_html
  
  :NOTES:
  使用node.js写HTTP Web服务与之前写的TCP Echo服务形式上非常相近。

  #+begin_src js
    var http = require("http");
  #+end_src

  #+begin_quote
  导入 [[http://nodejs.org/api/http.html][=http=]] 模块。 
  
  [[http://nodejs.org/api/http.html][=http=]] 模块封装了HTTP相关功能，包括HTTP服务器与HTTP客户端。
  \\
  \\
  #+end_quote

  #+begin_src js -r -n
    var server = http.createServer( function(req, res) {            (ref:web_server__createServer)
        res.writeHead(200, {'Content-Type': 'text/plain'});         (ref:web_server__response_header)
        res.end("hello node.js\n");                                 (ref:web_server__response_content)
    });
  #+end_src

  #+begin_quote
  [[(web_server__createServer)]] 调用 [[http://nodejs.org/api/http.html#http_http_createserver_requestlistener][http.createServer]] 创建 [[http://nodejs.org/api/http.html#http_class_web_server][http.Server]] 对象，参数为回调函数，当web服务器收到请求时调用该回调函数，回调函数接受两个参数：req（请求对象）、res（响应对象）。
  #+end_quote

  #+begin_quote
  [[(web_server__response_header)]] 发送HTTP响应状态码及消息头到客户端。
  #+end_quote

  #+begin_quote
  [[(web_server__response_content)]] 发送响应内容并结束当前请求。由于持久连接的存在，同一连接上可能存在多个请求-响应， [[http://nodejs.org/api/http.html#http_response_end_data_encoding][=end=]] 用于指示当前请求已处理完毕。
  #+end_quote
  
  #+begin_src js
      res.end("hello node.js\n");
  #+end_src
  等同于
  #+begin_src js
      res.write("hello node.js\n"); 
      res.end();
  #+end_src

  在客户端收到的响应中，有以下非预期的消息头出现：
  #+begin_example -r -n
    Date: Fri, 12 Jul 2013 08:28:42 GMT                            (ref:web_server__output_date)
    Connection: keep-alive                                         (ref:web_server__output_keep-alive)
    Transfer-Encoding: chunked                                     (ref:web_server__output_chunked)
  #+end_example
  这是node.js的默认设置，通过启用持久连接和流式数据传输，可以减少客户端连接和对响应数据的缓存，性能得到提升。
  
  hack一下消除以上非预期的消息头：
  #+begin_src js
    var server = http.createServer( function(req, res) {
        res.sendDate = false;
        res.shouldKeepAlive = false;
        res.useChunkedEncodingByDefault = false;
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end("hello node.js\n");
    });
  #+end_src
  #+begin_example
    ~$ curl -i http://localhost:8002
    HTTP/1.1 200 OK
    Content-Type: text/plain
    Connection: close
    
    hello node.js
  #+end_example
  \\
  \\
  :END:

* Node.js构建静态Http服务

  #+begin_html
  <div class="leftinfo" style="width:60%; font-size:0.6em;">
  #+end_html

  #+ATTR_HTML: class="codelink" style="right:41%;"
  [[../static/static_web_server.js][static\_web\_server.js]]
#+INCLUDE: "../static/static_web_server.js" src js -n

  #+begin_html
  </div>
  <div class="rightinfo" style="width:35%; font-size:0.7em;">
  #+end_html

  　　node.js的 [[http://nodejs.org/api/http.html#http_http][=http=]] 模块构建于 [[http://nodejs.org/api/net.html][=net=]] 模块之上，从TCP数据流中解析HTTP消息，提供了基本的HTTP服务。

  　　node.js以模块的方式提供了其它功能，如：
      
      - [[http://nodejs.org/api/url.html][=url=]] :: 解析url
      - [[http://nodejs.org/api/querystring.html][=querystring=]] :: 解析url查询字符串
      - [[https://npmjs.org/package/formidable][=formidable=]] :: 解析表单数据

  #+begin_html
  </div>
  #+end_html

* 基础Web框架：Connect

  #+ATTR_HTML: style="float:left; margin-left:1em; width:10em;"
  [[../static/dry.jpeg]]
  
  #+begin_quote
  [[http://nodejs.org/api/http.html#http_http][=http=]] 模块之上构建的基础Web框架\\
  采用插件式架构\\
  目标是成为高级Web框架的基石\\
  大量内置及 [[https://github.com/senchalabs/connect/wiki][第三方]] 中间件
  #+end_quote

  #+begin_center

  #+begin_src sh
    npm install connect
  #+end_src
  
  #+Caption: 常用的中间件
  #+ATTR_HTML: style="margin:0 auto; font-size:0.7em;"
  |-----------------+----------------------|
  | [[http://www.senchalabs.org/connect/logger.html][=logger=]]        | 请求日志记录         |
  | [[http://www.senchalabs.org/connect/bodyParser.html][=bodyParser=]]    | 请求消息体解析器     |
  | [[http://www.senchalabs.org/connect/cookieParser.html][=cookieParser=]]  | cookie解析器         |
  | [[http://www.senchalabs.org/connect/cookieSession.html][=cookieSession=]] | 基于cookie的会话支持 |
  | [[http://www.senchalabs.org/connect/static.html][=static=]]        | 静态文件服务         |
  | [[http://www.senchalabs.org/connect/query.html][=query=]]         | 查询字符串解析器     |
  | [[http://www.senchalabs.org/connect/errorHandler.html][=errorHandler=]]  | 错误处理             |
  |-----------------+----------------------|
  #+end_center

* 基于Connect的静态Http服务

  #+ATTR_HTML: class="codelink"
  [[../static/connect_static_web_server.js][connect\_static\_web\_server.js]]
#+INCLUDE: "../static/connect_static_web_server.js" src js -n

  #+begin_quote
  \\
  中间件并未包含依赖信息

  由于中间件可能依赖其它中间件的处理结果

  因此其排列顺序非常关键
  
  可以参照 [[http://www.senchalabs.org/connect/][Connect项目主页]] Middleware 部分给出的顺序

  对于第三方的中间件请查阅其文档
  #+end_quote

* Connect框架工作原理

  #+begin_html
  <div style="font-size:0.8em; background:url(../static/tools.jpeg) 90% no-repeat; background-size:contain;">
  #+end_html

  #+begin_quote
  构建Web服务需要使用大量的组件
  #+end_quote

  #+begin_quote
  =解析提交的表单=

  =权限验证=

  =会话管理=

  =静态文件服务=

  =压缩=

  =...=
  \\
  \\
  #+end_quote
  #+begin_html
  </div>
  <div style="background:url(../static/connect.jpeg) no-repeat; background-size:contain; font-size:0.8em;">
  #+end_html  

  #+begin_quote
   [[http://www.senchalabs.org/connect/][=Connect=]] 将它们串联起来
  \\
  \\
  #+end_quote

  #+begin_quote
  http请求依次流过这些组件
  
  每个组件对请求进行自已的处理

  它们靠请求及响应对象传递中间数据

  互相协作

  最终完成整个请求的处理
  #+end_quote

  #+begin_html
  </div>
  <div class="codeexplain"><a href="javascript: toggleNotesWindow();" target="_self">讲解</a></div>
  #+end_html

  :NOTES:
  [[http://www.senchalabs.org/connect/][=Connect=]] 提供 =use= 方法用于注册中间件到中间件队列中。

  #+begin_html
  <div style="font-size:0.7em;line-height:1em;">
  #+end_html

  #+begin_src artist
    +-----------------------------+       +-----------------------------+      +-----------------------------+ 
    |  +---------+                |       |  +---------+                |      |  +---------+                | 
    |  | request |                |       |  | request |                |      |  | request |                | 
    |  +---------+    +--------+  |       |  +---------+    +--------+  |      |  +---------+    +--------+  | 
    |                 |  next  +--+------>|                 |  next  +--+----->|                 |  next  |  |
    |  +---------+    +--------+  |       |  +---------+    +--------+  |      |  +---------+    +--------+  | 
    |  | response|                |       |  | response|                |      |  | response|                | 
    |  +---------+                |       |  +---------+                |      |  +---------+                | 
    +-----------------------------+       +-----------------------------+      +-----------------------------+ 
  #+end_src

  #+begin_html
  </div>
  #+end_html
  
  
  =use= 方法用于在匹配的请求路径上挂载中间件。
  
  #+Caption: =function= ( =route= , =fn= )
  | 参数  | 说明                                                |
  |-------+-----------------------------------------------------|
  | route | 请求路径模式。                                      |
  |       | 可选，默认为 =/= 匹配所有请求路径，                 |
  |       | 用于限定中间件处理范围。                            |
  |-------+-----------------------------------------------------|
  | fn    | 中间件。                                            |
  |       | 中间件是一个函数 ”function(req, res, next)“，     |
  |       | 其中 =req= 与 =res= 参数来自 [[http://nodejs.org/api/http.html#http_http][=http=]] [[http://nodejs.org/api//http.html#http_event_request][请求处理函数]] ， |
  |       | 中间件通常会在 =req= 与 =res= 上附加或修改属性，    |
  |       | 供其它中间件或应用逻辑利用，                        |
  |       | =next= 用于调用下一个中间件，                       |
  |       | 中间件可以完成当前请求，                            |
  |       | 则不必调用 =next= ，                                |
  |       | 否则需调用 =next= 由下一中间件继续处理。            |


  使用示例：
  #+begin_src js
    app.use('/public', connect.static(__dirname + '/public'));
  #+end_src
  
  上面的例子提供 =public= 目录的静态文件服务，假设当前项目目录结构为：

  #+begin_html
  <div style="font-size:0.7em;line-height:1em;">
  #+end_html
  #+begin_src artist
     docroot   
        |      
        |----public
        |       |
        |       -----node.jpeg 
  #+end_src
  #+begin_html
  </div>
  #+end_html
  
  那么可以这样访问到 =node.jpeg= ： http://localhost/public/node.jpeg 。

  如果上面的示例中，不指定 =route= ，则可以在根路径下访问到 =node.jpeg= ：http://localhost/node.jpeg 。

  指定 =route= 为 "/static" ， 则要这样访问： http://localhost/static/node.jpeg 。

  这是因为 [[http://www.senchalabs.org/connect/][=Connect=]] 在调用中间件之前，会将 =req= 路径中的 =route= 前缀删除，这样中间件可以挂载在任意路径下。

  :END:

* 高级Web框架：Express

  #+begin_quote
  Express是node.js的一个高性能、高级Web开发框架

  以 [[http://www.senchalabs.org/connect/][=Connect=]] 为基础\\
  \\
  \\
  #+end_quote

  #+begin_center
  #+ATTR_HTML: style="width:7em; margin-left:2em;"
  [[../static/mvc.jpeg]]
  #+end_center

* Express安装
  
  #+begin_example
  $ sudo npm install -g express
  $ express hello_express
  $ cd hello_express
  $ npm install -d
  $ node app.js
  #+end_example

  #+begin_html
  <div class="leftinfo">
  #+end_html

  #+ATTR_HTML: class="codelink" style="right:52.5%;"
  [[../static/hello_express/][hello\_express]]
  #+begin_example
    hello_express
    ├── app.js
    ├── package.json
    ├── public
    │   ├── images
    │   ├── javascripts
    │   └── stylesheets
    │       └── style.css
    ├── routes
    │   ├── index.js
    │   └── user.js
    └── views
        ├── index.jade
        └── layout.jade
  #+end_example

  #+begin_html
  </div>
  <div class="rightinfo">
  #+end_html

  #+ATTR_HTML: style="width:12.5em;"
  [[../static/hello_express.png]]
  
  #+begin_html
  </div>
  #+end_html

* Express项目：package.json

  #+begin_html
  <div class="leftinfo" style="font-size:0.8em;">
  #+end_html

  #+ATTR_HTML: class="codelink" style="right:52.5%"
  [[../static/hello_express/package.json][package.json]]
#+INCLUDE: "../static/hello_express/package.json" src js -n
  #+begin_html
  <div class="codeexplain"><a href="https://npmjs.org/doc/json.html">包配置文件</a></div>
  #+end_html

  #+begin_html
  </div>
  <div class="rightinfo" style="font-size:0.65em;">
  #+end_html

  - =name= 
  
    需依据项目进行修改，如改为 /hello\_express/

  - =version= 
  
    项目新版本发布时需升级版本号

  - =private= 

    私有项目，防止不小心对外发布

  - =scripts.start=
  
    定制的npm命令，可通过 /npm start/ 执行对应的命令

  - =dependencies.express=
  
    依赖的 /express/ 框架包版本

  - =dependencies.jade=

    依赖的 /jade/ 模板包版本

  #+begin_html
  </div>
  #+end_html

* Express项目：app.js

  #+begin_html
  <div class="leftinfo" style="font-size:0.5em;">
  #+end_html

  #+ATTR_HTML: class="codelink" style="right:52.5%"
  [[../static/hello_express/app.js][app.js]]
#+INCLUDE: "../static/hello_express/app.js" src js -n

  #+begin_html
  </div>
  <div class="rightinfo" style="font-size:0.65em;">
  #+end_html

  #+begin_html
  </div>
  #+end_html

* 参考资料
  - 《Javascript语言精粹》
  - [[http://jibbering.com/faq/notes/closures/][Javascript Closures]]
  - [[http://www.nodebeginner.org/index-zh-cn.html][Node.js入门]]
  - [[http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb][Understanding node.js]]
  - [[http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/][Understanding the node.js event loop « Mixu's tech blog]]
