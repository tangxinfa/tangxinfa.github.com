#+AUTHOR: 唐新发
#+EMAIL: tangxinfa@xunlei.com
#+DESCRIPTION: 90 minutes
#+OPTIONS: toc:nil

* Javascript简介

  #+begin_quote
  web浏览器上的唯一语言\\
  \\
  批着c外衣的lisp\\
  \\
  被误解最多的语言
  #+end_quote
  \\
  #+begin_src html
    <button onClick='alert("Hello Javascript");'>Click Me</button>
  #+end_src
  \\
  #+begin_center
    #+begin_html
    <button onClick='alert("Hello Javascript");'>Click Me</button>
    #+end_html
  #+end_center

* Javascript诞生

  　　1995年，Netscape（网景）打算在浏览器（Netscape Navigator 2.0）中嵌入Scheme，招募来Brendan Eich（布兰登·艾奇），事情很快变成在浏览器中嵌入一种像Java的脚本语言，Brendan Eich在10天的时间里写出了JavaScript的雏形Mocha（摩卡），Mocha也被用于嵌入Netscape的服务器产品LiveWire，为了便于市场营销Mocha改名为LiveScript，1995年底Netscape和Sun商谈后终将LiveScript更名为JavaScript。

* Javascript扩张
  
  　　JavaScript 1.0随Netscape Navigator 2.0发行并取得了成功，随后Netscape在Netscape Navigator 3.0中发布了JavaScript 1.1版，这个时候微软决定进军浏览器，发布了IE 3.0并搭载了一个JavaScript的克隆版，叫做JScript。

  　　1997年，JavaScript 1.1作为一个草案提交给欧洲计算机制造商协会（ECMA），完成了标准化（ECMA-262标准，ECMAScript脚本语言）。

  　　后来Netscape在浏览器大战中不敌微软，LiveWire服务器产品也跟着失败了，服务器端JavaScript消失了。

* Javascript统治
  
  #+begin_center
  #+Caption: Javascript驱动Web
  #+ATTR_HTML: style="width:25em;" title="javascript driver the web"
  [[../static/browsers.png]]  
  #+end_center

* Javascript标准：ECMAScript

  ECMAScript 描述了以下内容：
    - 语法
    - 类型
    - 语句
    - 关键字
    - 保留字
    - 运算符
    - 对象

* Javascript的组成

  一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：
    - 核心（ECMAScript）
    - 文档对象模型（DOM）
    - 浏览器对象模型（BOM）

* Javascript特点

  #+begin_quote
  函数式\\
  \\
  原型继承\\
  \\
  弱类型\\
  \\
  词法作用域
  #+end_quote

* Javascript特性：“类”

  #+begin_quote
  Javascript是\\
  \\
  基于原型\\
  \\
  面向对象语言\\
  \\
  没有“类”概念\\
  \\
  \\
  原型＋构造函数＋new关键字＝类
  #+end_quote

* Javascript特性：“类”（示例）

  #+ATTR_HTML: :textarea
  #+begin_src javascript -n
    function Man(name, age) {
        this.name = name;
        this.age  = age;
    }
    Man.prototype.introduce = function(){
        return this.name + " is " + this.age;
    };
    
    var man1 = new Man("jack", 24);
    var man2 = new Man("tom", 25);
    console.log(man1.introduce());
    console.log(man2.introduce());
  #+end_src
  \\
  #+begin_example
    jack is 24
    tom is 25
  #+end_example
      
* Javascript特性：闭包

  #+begin_quote
  闭包是\\
  代码块（通常是函数）\\
  和\\
  创建该代码块的上下文中数据\\
  的结合。\\
  \\
  \\
  表现为\\
  函数可以访问外部作用域定义的变量\\
  即使外部作用域已经退出
  #+end_quote

* Javascript特性：闭包（示例）

  #+begin_src javascript -n
    function Woman(name, age) {
        this.name = name;
        this.introduce = function(){
            return this.name + " is " + (age - 10);
        };
    }
    var woman1 = new Woman("mary", 34);
    var woman2 = new Woman("rose", 45);
    console.log(woman1.introduce());
    console.log(woman2.introduce());
  #+end_src
  \\
  #+begin_example
    mary is 24
    rose is 35
  #+end_example

* 常见的Web后端开发技术

  #+begin_center
  #+Caption: Perl
  #+ATTR_HTML: style="width:3em;" title="Perl"
  [[../static/perl.jpeg]]

  #+Caption: Php
  #+ATTR_HTML: style="width:3em;" title="Php"
  [[../static/php.jpeg]]

  #+Caption: Python
  #+ATTR_HTML: style="width:3em;" title="Python"
  [[../static/python.jpeg]]

  #+Caption: Ruby
  #+ATTR_HTML: style="width:3em;" title="Ruby"
  [[../static/ruby.jpeg]]
  #+end_center

  #+begin_center
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/apache.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/nginx.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/lighttpd.jpeg]]
  #+end_center
  \\
  #+begin_center
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mysql.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/postgres.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/oracle.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/memcache.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/redis.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mongodb.jpeg]]
  #+end_center

* 今天要介绍的Web后端开发技术

  #+begin_center
  #+ATTR_HTML: style="width:20.8em;" title="Node"
  [[../static/node.jpeg]]
  #+end_center
  \\
  \\
  \\
  #+begin_center
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mysql.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/postgres.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/oracle.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/memcache.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/redis.jpeg]]
  #+ATTR_HTML: style="width:2.5em;"
  [[../static/mongodb.jpeg]]
  #+end_center

* Node.js简介
  
  　　Node.js是在Chrome的Javascript引擎之上构建的一个平台，
  很容易用来构建 =高性能= 、 =可扩展= 的网络应用程序。
  \\
  \\
  \\
  　　Node.js是 =单线程= 基于 =事件驱动= 、 =非阻塞I/O模型= 从而表现得轻巧、高效，
  适用于开发 =数据密集型= 的 =实时响应= 分布式应用程序。

* Node.js简介

  Node.js =不是=
  #+begin_quote
  像php、python、perl、ruby这样的 =语言=\\
  \\
  像CakePHP、Django、Rails这样的服务器端 =框架=\\
  \\
  像JQuery、ExtJS、Backbone.js这样的浏览器端 =库=\\
  #+end_quote

* Node.js现状

  #+begin_html
  <div class="leftinfo">
  #+end_html

  活跃的社区

  #+ATTR_HTML: style="width:13em;" title="github最受欢迎的项目Top5"
  [[../static/github_starred_top5.png]]

  #+begin_html
  </div>
  #+end_html

  #+begin_html
  <div class="rightinfo">
  #+end_html

  丰富的模块

  #+ATTR_HTML: style="width:13em;"
  [[../static/npmjs_screenshot.png]]

  #+begin_html
  </div>
  #+end_html

* Node.js用户案例

  #+begin_html
    <center style="font-size:0.8em">
  #+end_html
  《[[http://www.csdn.net/article/2012-10-08/2810589-LinkedIn_Rails_to_Node][LinkedIn移动端用Node替代Rails：减少90%服务器 速度提升20倍]]》
  #+begin_html
    </center>
  #+end_html

  #+begin_html
  <div class="leftinfo">
  #+end_html
  #+ATTR_HTML: style="width:10em;"
  [[../static/linkedin.jpeg]]
  #+begin_quote
  在服务端\\
  我们的整个移动软件栈完全使用Node构建\\
  第一个原因是可扩展\\
  第二个原因是性能上的巨大提升
  #+end_quote
  #+begin_html
  </div>
  <div class="rightinfo" style="font-size:0.7em;">
  #+end_html
  Node.js的优势在于：\\
  - 更好的性能以及更少的内存占用，在某型情景下性能提升20倍
  - 程序员可以充分发挥他们JavaScript的技巧
  - 前端与后端开发人员可以在一个小组内协作
  - 服务器从30台减少到只有3台，硬件资源利用率提升10倍，并且还有提升的空间。
  - 开发工作可以更加专注在应用开发，而不是到处去救火
  #+begin_html
  </div>
  #+end_html

* Node.js安装
  
  #+begin_html
    <div class="leftinfo">
  #+end_html

  [[http://nodejs.org/download/]]

  #+ATTR_HTML: style="width:11em;"
  [[../static/node_download.png]]

  #+begin_html
    </div>
    <div class="rightinfo" style="font-size:0.7em;">
  #+end_html

  - /usr/local/bin/node :: 主程序
    
  - /usr/local/bin/npm :: 模块管理程序

  - /usr/local/lib/node\_modules :: 全局模块目录

  #+begin_html
    </div>
    <div style="clear:both;"></div>
  #+end_html

  #+begin_src sh
    wget http://nodejs.org/dist/v0.10.12/node-v0.10.12.tar.gz
    tar xzf node-v0.10.12.tar.gz
    ./configure
    make
    sudo make install
  #+end_src

  #+begin_example
    ~$ node -e 'console.log("hello node.js");'
    hello node.js
  #+end_example

* Node.js模块机制

  #+begin_html
    <div class="leftinfo">
  #+end_html

  #+begin_quote
  JavaScript没有模块系统\\
  所有js文件中定义的顶级对象名存在于同一个命名空间\\
  \\
  #+end_quote

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_quote
  - [[http://www.commonjs.org][CommonJS]]规范 :: 其目标是为了构建JavaScript在包括Web服务器，桌面，命令行工具，及浏览器方面的生态系统。
  #+end_quote

  #+begin_html
      </div>
      <div style="clear:both; padding:0;">
      </div>
      <div class="leftinfo" style="font-size:0.7em;">
  #+end_html

  [[http://wiki.commonjs.org/wiki/Modules/1.1][CommonJS模块规范]]：
  #+begin_src artist
    
    +-------------+
    | module.js --+->模块是普通的js文件
    |             |                    
    | +---------+ |
    | | require +-+->用于导入其它模块接口的函数
    | +---------+ |  
    | +---------+ |  
    | | exports +-+->用于导出接口的对象
    | +---------+ |  
    | +---------+ |  
    | | module  +-+->当前模块对象
    | +---------+ |  
    |    ...  ----+->其它用户定义对象为模块私有
    +-------------+
  #+end_src

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_quote
  在Node.js应用程序中\\
  首次require一个模块执行其代码\\
  返回其exports对象\\
  该exports对象会被Node.js缓存\\
  当再次require该模块直接返回缓存结果\\
  \\
  exports变量是module.exports对象的引用\\
  \\
  该模块不会对全局命名空间造成影响
  #+end_quote
  
  #+begin_html
    </div>
  #+end_html

* Node.js模块示例

  =woman.js=
  #+begin_src javascript -n
    var value = 10;
    exports.Woman = function (name, age) {
        this.name = name;
        this.introduce = function(){
            return this.name + " is " + (age - value);
        };
    };
  #+end_src
  \\
  #+begin_src javascript -n
    var Woman = require("./woman.js").Woman;
    var woman1 = new Woman("mary", 34);
    var woman2 = new Woman("rose", 45);
    console.log(woman1.introduce());
    console.log(woman2.introduce());
  #+end_src

* Node.js模块示例（类即模块）

  =woman.js=
  #+begin_src javascript -n
    var value = 10;
    module.exports = function (name, age) {
        this.name = name;
        this.introduce = function(){
            return this.name + " is " + (age - value);
        };
    };
  #+end_src
  \\
  #+begin_src javascript -n
    var Woman = require("./woman.js");
    var woman1 = new Woman("mary", 34);
    var woman2 = new Woman("rose", 45);
    console.log(woman1.introduce());
    console.log(woman2.introduce());
  #+end_src

* Node.js包机制
  
  #+begin_html
    <div class="leftinfo">
  #+end_html

  #+begin_quote
  JavaScript没有包管理系统\\
  不能自动加载和安装依赖\\
  不利于开发大规模应用
  #+end_quote

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_quote
  - [[http://wiki.commonjs.org/wiki/Packages/1.1][CommonJS包规范]] :: 存在package.json文件的目录即为包
  #+end_quote

  #+begin_html
        </div>
        <div style="clear:both; padding:0;">
        </div>
        <div class="leftinfo" style="font-size:0.425em;" title=" /usr/local/lib/node_modules/npm/node_modules/tar/package.json">
  #+end_html
  
  #+begin_src javascript -n -r
    {
      "author": {
        "name": "Isaac Z. Schlueter",
        "email": "i@izs.me",
        "url": "http://blog.izs.me/"
      },
      "name": "tar",                                    (ref:package_specs__name)
      "description": "tar for node",
      "version": "0.1.17",                              (ref:package_specs__version)
      "repository": {
        "type": "git",
        "url": "git://github.com/isaacs/node-tar.git"
      },
      "main": "tar.js",                                 (ref:package_specs__main)
      "scripts": {                                      (ref:package_specs__scripts)
        "test": "tap test/*.js"
      },
      "dependencies": {                                 (ref:package_specs__dependencies)
        "inherits": "1.x",
        "block-stream": "*",
        "fstream": "~0.1.8"
      },
      "devDependencies": {
        "tap": "0.x",
        "rimraf": "1.x"
      },
      "license": "BSD",
      "readme": "...",
      "readmeFilename": "README.md",
      "_id": "tar@0.1.17",
      "dist": {
        "shasum": "408c8a95deb8e78a65b59b1a51a333183a32badc"
      },
      "_from": "tar@0.1.17",
      "_resolved": "https://registry.npmjs.org/tar/-/tar-0.1.17.tgz"
    }
  #+end_src

  #+begin_html
    </div>
    <div class="rightinfo" style="font-size:0.7em">
  #+end_html

  #+ATTR_HTML: style="border-style:hidden; font-size:0.75em;"
  | =name= [[(package_specs__name)]]                 | 包名                       |
  | =version= [[(package_specs__version)]]           | 版本号                     |
  | =main= [[(package_specs__main)]]                 | 当包被程序引用时需载入模块 |
  | =scripts= [[(package_specs__scripts)]]           | 用于包管理                 |
  | =dependencies= [[(package_specs__dependencies)]] | 依赖的其它包               |

  #+begin_html
    </div>
  #+end_html

* Node.js包管理工具

  #+begin_html
  <style type="text/css">
    .npm-logo img {
      width: 7em;
    }
  </style>
  #+end_html

  #+ATTR_HTML: class="npm-logo"
  [[https://npmjs.org/][../static/npm.png]]

  #+begin_quote
  - =npm install <name>= :: 安装包到本地模块目录（./node\_modules）
  - =npm install -g <name>= :: 安装包到全局模块目录（/usr/local/lib/node\_modules）
  - =npm link= :: 将当前包链接全局模块目录下
  - =npm link <name>= :: 将全局包链接本地模块目录下
  全局模块目录不在Node.js的模块搜索范围内\\
  将全局安装的包链接到本地模块目录即可\\
  #+end_quote

* Node.js模块定位

  #+begin_html
    <div class="leftinfo" style="font-size:0.7em;">
  #+end_html

  =require(X)如何定位到模块文件？=

  - require("fs")
    
    直接加载核心模块

  - require("./X")
  - require("../X")
  - require("/X")

    指定路径加载模块

  - require("X")

    搜索路径加载模块

  #+begin_html
    </div>
    <div class="rightinfo" style="font-size:0.6em;">
  #+end_html
  
  - 指定路径加载模块
      - 指定路径下X文件
      - 指定路径下X.js文件
      - 指定路径下X.node文件
      - 指定路径下X/package.json文件中的main对应的文件
      - 指定路径下X/index.js
      - 指定路径下X/index.node

  - 搜索路径加载模块

    依次尝试以下路径进行模块加载

    - 当前目录下的node\_modules目录
    - 上一级目录下的node\_modules目录，直到根目录为止
    - NODE\_PATH环境变量指定的各个路径
    - 用户根目录下的.node\_modules目录
    - 用户根目录下的.node\_libraries目录
    - node.js安装目录前缀下的/lib/node
      
      通常为：/usr/local/lib/node

  #+begin_html
    </div>
  #+end_html
  
* Node.js示例：Echo服务器

  =echo_server.js=
  #+begin_html
  <a href="javascript: toggleNotesWindow();" target="_self" style="font-size:0.5em; padding-top:0.5em;">讲解</a>
  #+end_html
  #+begin_src javascript -n
    var net = require('net');
    
    var server = net.createServer(
        function (socket) {
            socket.pipe(socket);
        }
    );
    
    server.listen(8001);
    console.log("Server running");
  #+end_src

  #+begin_html
    <div class="leftinfo">
  #+end_html

  #+begin_example
  ~$ node ./echo_server.js
  Server running

  #+end_example

  #+begin_html
    </div>
    <div class="rightinfo">
  #+end_html

  #+begin_example
    ~$ telnet 127.0.0.1 8001
    hello
    hello
  #+end_example

  #+begin_html
    </div>
    <div style="clear:both;"></div>
  #+end_html

  #+begin_quote
  在Node.js中，除了代码，一切都是并行的！\\
  #+end_quote

  :NOTES:
  现在我们来逐行解释发生了什么：

  #+begin_src sh
    node ./echo_server.js
  #+end_src

  #+begin_quote
  node.js解释执行echo\_server.js，
  
  然后进入事件循环，

  如果没有事件需要处理则退出程序。
  \\
  \\
  #+end_quote

  #+begin_src javascript
  var net = require('net');
  #+end_src
  
  #+begin_quote
  导入 [[http://nodejs.org/api/net.html][net]] 模块，它是node.js自带的核心模块，对异步网络进行了封装。

  net模块的js代码将被执行，返回该模块导出的一些函数及“类”。
  \\
  \\
  #+end_quote

  #+begin_src javascript -n -r
    var server = net.createServer(             (ref:echo_server__createServer)
        function (socket) {                    (ref:echo_server__createServer_callback)
            socket.pipe(socket);               (ref:echo_server__createServer_pipe)
        }
    );
  #+end_src

  #+begin_quote
  [[(echo_server__createServer)]] net.createServer创建一个tcp服务器对象，参数为绑定到服务器 [[http://nodejs.org/api/net.html#net_event_connection][connection]] 事件的回调函数，当node.js成功接收到一个连接时，该回调函数将被调用。
  
  [[(echo_server__createServer_callback)]] 该回调函数的参数为新建立的tcp连接对象，它是一个 [[http://nodejs.org/api/net.html#net_class_net_socket][net.Socket]] 类实例，

  [[(echo_server__createServer_pipe)]] echo的实现使用了Socket.pipe方法，该方法来自Socket的父类，将当前对象读取到的数据转发到参数指定的目标对象。
  \\
  \\
  #+end_quote

  #+begin_src javascript
    server.listen(8001);
  #+end_src

  #+begin_quote
  TCP服务器在绑定在8001端口进行监听，这里省略了第二个参数 =host= （其默认值为 =INADDR_ANY= ），第三个参数 =backlog= (其默认值为 =511= )，第四个数 =callback= ，
  net.Server的 =listen= 方法也是非阻塞的，绑定成功会调用回调函数 =callback= ，失败会发出 =error= 事件，这里为了示例的简单性没有进行错误处理。
  \\
  \\
  #+end_quote

  #+begin_src javascript
      console.log("Server running");
  #+end_src

  #+begin_quote
  node.js引入了浏览器端JavasSript常见的一些功能。
  
  如：console对象，用于输出日志；setTimeout函数，用于延迟执行。

  但浏览器上特有东西在node.js中是不存在的，如：window全局对象的，在node.js中对应的是 =process= 全局对象。
  \\
  \\
  #+end_quote

  接下来就由node.js的事件循环接管了，应用程序的逻辑会在事件回调中得以执行。

  :END:

* Node.js程序运行得非常快

  #+begin_html
    <style type="text/css" media="screen">
    .data-access-latency-table .right {
       border-left: 1px solid black;
       border-right: 1px solid black;
    }
    .data-access-latency-table td {
       padding:0 0.5em;
    }
    </style>   
    
  #+end_html

  #+CAPTION: I/O操作耗时对比
  #+ATTR_HTML: style="width:70%; margin:0 auto; border: 1px; padding:" class="data-access-latency-table"
  |----------+-----------+--------------|
  | I/O      | CPU Cycle | Type         |
  |----------+-----------+--------------|
  | L1-cache |         3 |              |
  | L2-cache |        14 | Non-blocking |
  | RAM      |       250 |              |
  |----------+-----------+--------------|
  | Disk     |  41000000 | Blocking     |
  | Network  | 240000000 |              |
  |----------+-----------+--------------|

  #+ATTR_HTML: style="float:left; margin-left:4em; width:5em;"
  [[../static/nonblocking.jpeg]]
  
  #+begin_quote
  \\
  Node.js是一个全新的开发平台\\
  \\
  所有会阻塞的api都以异步回调的方式进行封装\\
  \\
  #+end_quote

* Node.js构建Http服务

  =web_server.js=
  #+begin_html
  <a href="javascript: toggleNotesWindow();" target="_self" style="font-size:0.5em; padding-top:0.5em;">讲解</a>
  #+end_html

  #+begin_src javascript -n
    var http = require("http");
    
    var server = http.createServer( function(req, res) {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end("hello node.js\n");
    });
    
    server.listen(8002);
  #+end_src

  #+begin_example -n
    ~$ curl -i http://localhost:8002
    HTTP/1.1 200 OK
    Content-Type: text/plain
    Date: Fri, 12 Jul 2013 08:28:42 GMT
    Connection: keep-alive
    Transfer-Encoding: chunked
    
    hello node.js
  #+end_example
  
  :NOTES:
  使用node.js写HTTP Web服务与之前写的TCP Echo服务形式上非常相近。

  #+begin_src javascript
    var http = require("http");
  #+end_src

  #+begin_quote
  导入 [[http://nodejs.org/api/http.html][=http=]] 模块。 
  
  [[http://nodejs.org/api/http.html][=http=]] 模块封装了HTTP相关功能，包括HTTP服务器与HTTP客户端。
  \\
  \\
  #+end_quote

  #+begin_src javascript -r -n
    var server = http.createServer( function(req, res) {            (ref:web_server__createServer)
        res.writeHead(200, {'Content-Type': 'text/plain'});         (ref:web_server__response_header)
        res.end("hello node.js\n");                                 (ref:web_server__response_content)
    });
  #+end_src

  #+begin_quote
  [[(web_server__createServer)]] 调用 [[http://nodejs.org/api/http.html#http_http_createserver_requestlistener][http.createServer]] 创建 [[http://nodejs.org/api/http.html#http_class_web_server][http.Server]] 对象，参数为回调函数，当web服务器收到请求时调用该回调函数，回调函数接受两个参数：req（请求对象）、res（响应对象）。
  #+end_quote

  #+begin_quote
  [[(web_server__response_header)]] 发送HTTP响应状态码及消息头到客户端。
  #+end_quote

  #+begin_quote
  [[(web_server__response_content)]] 发送响应内容并结束当前请求。由于持久连接的存在，同一连接上可能存在多个请求-响应， =[[http://nodejs.org/api/http.html#http_response_end_data_encoding][end]]= 用于指示当前请求已处理完毕。
  #+end_quote
  
  #+begin_src javascript
      res.end("hello node.js\n");
  #+end_src
  等同于
  #+begin_src javascript
      res.write("hello node.js\n"); 
      res.end();
  #+end_src

  在客户端收到的响应中，有以下非预期的消息头出现：
  #+begin_example -r -n
    Date: Fri, 12 Jul 2013 08:28:42 GMT                            (ref:web_server__output_date)
    Connection: keep-alive                                         (ref:web_server__output_keep-alive)
    Transfer-Encoding: chunked                                     (ref:web_server__output_chunked)
  #+end_example
  这是node.js的默认设置，通过启用持久连接和流式数据传输，可以减少客户端连接和对响应数据的缓存，性能进一步提升。
  
  hack一下消除以上非预期的消息头：
  #+begin_src javascript
    var server = http.createServer( function(req, res) {
        res.sendDate = false;
        res.shouldKeepAlive = false;
        res.useChunkedEncodingByDefault = false;
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end("hello node.js\n");
    });
  #+end_src
  #+begin_example
    ~$ curl -i http://localhost:8002
    HTTP/1.1 200 OK
    Content-Type: text/plain
    Connection: close
    
    hello node.js
  #+end_example
  \\
  \\
  :END:

* Node.js构建Http服务：Connect
* Node.js构建Http服务：Express
* Node.js超越Http服务
* Javascript工具：Jslint
* 浏览器中的Javascript
* C10K问题
* select与epoll
* 事件回调
* Javascript从前端到后端
* V8引擎简介
* 参考资料
  - 《Javascript语言精粹》
  - [[http://jibbering.com/faq/notes/closures/][Javascript Closures]]
  - [[http://www.nodebeginner.org/index-zh-cn.html][Node.js入门]]
  - [[http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb][Understanding node.js]]
  - [[http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/][Understanding the node.js event loop « Mixu's tech blog]]
