<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>node - 看看俺 – KanKanAn.com</title>
        <description>记我所思，忆我所为。</description>
        <link>http://blog.kankanan.com/tag/node.xml</link>
        <lastBuildDate>Mon, 20 Jul 2015 09:41:52 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <image>
            <title>node - 看看俺 – KanKanAn.com</title>
            <url>http://blog.kankanan.com/static/favicon.ico</url>
            <link>http://blog.kankanan.com/tag/node.xml</link>
        </image>
        <copyright>版权所有 © 2011-2015 看看俺 – KanKanAn.com</copyright>
        <generator>Feed for Node.js</generator>
        <category>技术</category>
        <item>
            <title><![CDATA[使用node.js的对象模式验证模块joi引入强类型]]></title>
            <link>/article/4f7f7528-node.js-76845bf98c616a215f0f9a8c8bc16a215757-joi-5f1551655f3a7c7b578b.html</link>
            <guid>/article/4f7f7528-node.js-76845bf98c616a215f0f9a8c8bc16a215757-joi-5f1551655f3a7c7b578b.html</guid>
            <pubDate>Mon, 13 Jul 2015 10:44:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>弱类型的Javascript

<p>
Javascript是一门弱类型的语言，定义变量不需要指定类型，可以为同一个变量赋任意类型的值。误用类型不会报错，而结果会让你大吃一惊：
</p>

<pre class="example">
&gt; "1" + 1
'11'
&gt; if ("false") { console.log("yes") } else { console.log("no"); }
yes
undefined
&gt;
</pre>

<p>
redis中很多数据结构取出时都是字符串值（如：set、hash），调用方需要自行将它转换成正确的类型（如：Boolean、Date、Number），如果不转换成正确的类型会导致冗长的代码，如Boolean类型：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">if</span> ((String(model.stoped) == <span style="color: #8abeb7;">'true'</span>)) {
<span style="background-color: #373b41;"> </span>   <span style="color: #969896; font-style: italic;">// </span><span style="color: #969896; font-style: italic;">Do something when stoped.</span>
}
</pre>
</div>

<p>
如果手工转换成正确的类型肯定要写很多样板代码了。
</p>
</li>

<li>对象模式验证模块 <a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a>

<p>
有很多的ORM（ Object Relational Mapping 对象关系映射）库都能够实现强类型的数据模型，但是它们都相当的复杂，支持各种各样的数据库后端，支持一对一、一对多、多对多等数据关系，但是很少支持分表分库，我们的系统一般是数据模型简单但要考虑用户量大了横向扩展，所以一开始就进行了分表分库，无法使用重型的ORM。
</p>

<p>
如果有一个能够自动根据模式（Schema）定义对值进行类型转换的库，一定会非常有用。
</p>

<p>
<a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a> 一个Javascript对象模式描述语言以及验证（Object schema description language and validator for JavaScript objects）的库，它可以完成对象类型转换以及合法性验证。
</p>
</li>

<li><a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a> 的用法示例

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">joi</span> = require(<span style="color: #8abeb7;">'joi'</span>);
<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">redis</span> = require(<span style="color: #8abeb7;">'redis'</span>);

<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">client</span> = redis.createClient(6379, <span style="color: #8abeb7;">'127.0.0.1'</span>);

<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">User</span> = <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">options</span>) {
<span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (! options) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   options = {};
<span style="background-color: #373b41;"> </span>   }

<span style="background-color: #373b41;"> </span>   <span style="color: #81a2be;">this</span>.id = options.id || 0;
<span style="background-color: #373b41;"> </span>   <span style="color: #81a2be;">this</span>.name = options.name || <span style="color: #8abeb7;">''</span>;
<span style="background-color: #373b41;"> </span>   <span style="color: #81a2be;">this</span>.male = options.male || <span style="color: #81a2be;">true</span>;
<span style="background-color: #373b41;"> </span>   <span style="color: #81a2be;">this</span>.birthday = options.birthday;
};

User.schema = joi.object().keys({
<span style="background-color: #373b41;"> </span>   id: joi.number().integer().min(1),
<span style="background-color: #373b41;"> </span>   name: joi.string().required(),
<span style="background-color: #373b41;"> </span>   male: joi.<span style="color: #81a2be;">boolean</span>().<span style="color: #b5bd68;">default</span>(<span style="color: #81a2be;">true</span>),
<span style="background-color: #373b41;"> </span>   birthday: joi.date().required()
});

User.find = <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">id</span>, <span style="color: #f0c674;">callback</span>) {
<span style="background-color: #373b41;"> </span>   client.hgetall(<span style="color: #8abeb7;">"user:"</span> + id, <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">err</span>, <span style="color: #f0c674;">value</span>) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (err) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">return</span> callback(err);
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   } <span style="color: #b5bd68;">else</span> <span style="color: #b5bd68;">if</span> (! value) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">return</span> callback(<span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Error</span>(<span style="color: #8abeb7;">"User not found"</span>));
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   }

<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   joi.validate(value, User.schema, callback);
<span style="background-color: #373b41;"> </span>   });
};

User.<span style="color: #81a2be;">prototype</span>.save = <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">callback</span>) {
<span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">value</span> = {};
<span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">for</span>(<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">fieldName</span> <span style="color: #b5bd68;">in</span> <span style="color: #81a2be;">this</span>) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (<span style="color: #b5bd68;">typeof</span>(<span style="color: #81a2be;">this</span>[fieldName]) != <span style="color: #8abeb7;">'function'</span>) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   value[fieldName] = <span style="color: #81a2be;">this</span>[fieldName];
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   }
<span style="background-color: #373b41;"> </span>   }
<span style="background-color: #373b41;"> </span>   joi.validate(value, User.schema, <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">err</span>, <span style="color: #f0c674;">validatedValue</span>) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (err) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">return</span> callback(err);
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   }

<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   client.hmset(<span style="color: #8abeb7;">"user:"</span> + validatedValue.id, validatedValue, callback);
<span style="background-color: #373b41;"> </span>   });
};


<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">user</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">User</span>({
<span style="background-color: #373b41;"> </span>   id: 1,
<span style="background-color: #373b41;"> </span>   name: <span style="color: #8abeb7;">"txf"</span>,
<span style="background-color: #373b41;"> </span>   male: <span style="color: #81a2be;">true</span>,
<span style="background-color: #373b41;"> </span>   birthday: <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Date</span>(<span style="color: #8abeb7;">"1983-03-22"</span>)
});

user.save(<span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">err</span>) {
<span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (err) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   console.error(<span style="color: #8abeb7;">"user save error("</span> + err.toString() + <span style="color: #8abeb7;">")"</span>);
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   client.quit();
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">return</span>;
<span style="background-color: #373b41;"> </span>   }

<span style="background-color: #373b41;"> </span>   console.info(<span style="color: #8abeb7;">"user saved"</span>);

<span style="background-color: #373b41;"> </span>   User.find(user.id, <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">err</span>, <span style="color: #f0c674;">user</span>) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   client.quit();
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (err) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   console.error(<span style="color: #8abeb7;">"user find error("</span> + err.toString() + <span style="color: #8abeb7;">")"</span>);
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">return</span>;
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   }

<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   console.log(<span style="color: #8abeb7;">"user found: "</span> + JSON.stringify(user));
<span style="background-color: #373b41;"> </span>   });
});
</pre>
</div>

<p>
运行结果：
</p>

<div class="org-src-container">

<pre class="src src-js">user saved
user found: {<span style="color: #8abeb7;">"id"</span>:1,<span style="color: #8abeb7;">"name"</span>:<span style="color: #8abeb7;">"txf"</span>,<span style="color: #8abeb7;">"male"</span>:<span style="color: #81a2be;">true</span>,<span style="color: #8abeb7;">"birthday"</span>:<span style="color: #8abeb7;">"1983-03-22T00:00:00.000</span><span style="color: #8abeb7; text-decoration: underline;">Z"</span><span style="text-decoration: underline;">}</span>
</pre>
</div>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Node.js服务器TCP死连接问题诊断]]></title>
            <link>/article/node.js-670d52a15668-tcp-6b7b8fde63a595ee98988bca65ad.html</link>
            <guid>/article/node.js-670d52a15668-tcp-6b7b8fde63a595ee98988bca65ad.html</guid>
            <pubDate>Thu, 16 Apr 2015 12:29:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
最近一段时间，由于开发工作开始跟嵌入式相关，开始遇到一个问题：TCP死连接。
</p>

<p>
TCP死连接症状是这样的：通信双方从一方系统上看已经断开（不存在），但是另一方系统上看却是连接中（ESTABLISHED状态）。
</p>

<p>
TCP死连接一般在一方（或中间线路上的设备）断电、死机后出现，此时由于另一方收不到断开连接的IP报文，会认为连接仍然存在，日积月累会耗光文件描述符空间从而导致性能下降，最终拒绝服务。
</p>

<p>
对付这种问题，一般需要双方都进行连接心跳检测。比如：连接空闲一段时间后一方发一个心跳请求，另一端回个心跳响应，心跳请求发送方一段时间后还收不到响应则认为连接已断开，心跳请求接收方一段时间内没有收到心跳请求也认为连接已断开。
</p>

<p>
需要注意到的是node.js的tls服务器端握手超时处理不当可能会导致TCP死连接出现，有问题的代码示例如下：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">options</span> = {
<span style="background-color: #373b41;"> </span>   key: <span style="color: #8abeb7;">"..."</span>,
<span style="background-color: #373b41;"> </span>   cert: <span style="color: #8abeb7;">"..."</span>,
<span style="background-color: #373b41;"> </span>   handshakeTimeout: 10*1000,
<span style="background-color: #373b41;"> </span>   plain: <span style="color: #81a2be;">true</span>,
<span style="background-color: #373b41;"> </span>   ssl: <span style="color: #81a2be;">true</span>
};

<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">tlsServer</span> = tls.createServer(options, app).listen(5433, 8192, <span style="color: #b5bd68;">function</span>(){
<span style="background-color: #373b41;"> </span>   logger.log(<span style="color: #8abeb7;">'tls server listening on port 5433'</span>);
});

tlsServer.on(<span style="color: #8abeb7;">'clientError'</span>, <span style="color: #b5bd68;">function</span> (<span style="color: #f0c674;">exception</span>, <span style="color: #f0c674;">socket</span>) {
<span style="background-color: #373b41;"> </span>   logger.warn(<span style="color: #8abeb7;">'tls server client('</span> + socket.remoteAddress + <span style="color: #8abeb7;">':'</span> + socket.remot<span style="text-decoration: underline;">ePort +</span><span style="color: #8abeb7; text-decoration: underline;">') error('</span><span style="text-decoration: underline;"> + exception + </span><span style="color: #8abeb7; text-decoration: underline;">')'</span><span style="text-decoration: underline;">);</span>
});
</pre>
</div>

<p>
上面的代码通过指定 <code>handshakeTimeout</code> 使用指定SSL握手超时时间，但是并未关闭底层的TCP连接，从而导致TCP连接泄露，在 <code>clientError</code> 事件处理函数中添加以下释放语句即可：
</p>

<div class="org-src-container">

<pre class="src src-js">socket.destroy();
</pre>
</div>

<p>
除了常见的断电、死机引起TCP死连接外，这里还有一个论坛帖子论坛其它原因：《<a href="http://serverfault.com/questions/504187/too-many-established-connections-left-open">Too many established connections left open</a>》。
</p>

<p>
另外还有 linux 内核的 tcp keepalive机制作为心跳解决方案：《<a href="http://machael.blog.51cto.com/829462/211989/">linux下使用TCP存活(keepalive)定时器</a>》。
</p>

<p>
谨记：除了主动通过连接发送数据外，其它情况下操作系统可能不会告诉你连接已经关闭了。
</p>

<p>
要彻底解决这个问题，除了要避免泄露（或忘记关闭）TCP连接外，要有心跳机制，还需要从代码层面进行防御性编程，如：对于读写操作设置超时时间，一旦超时主动关闭连接。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[理解node.js中的Error对象]]></title>
            <link>/article/740689e3-node.js-4e2d7684-error-5bf98c61.html</link>
            <guid>/article/740689e3-node.js-4e2d7684-error-5bf98c61.html</guid>
            <pubDate>Tue, 09 Dec 2014 05:38:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
Error对象在 <a href="http://nodejs.org">node.js</a> 程序中无处不在，但是关于它在 <a href="http://nodejs.org/docs/latest/api/all.html">node.js文档</a> （写这篇文章时node.js的最新版本为v0.10.33）中却找不到描述资料，只在以下部分提及：
</p>

<dl class="org-dl">
<dt> <a href="http://nodejs.org/docs/latest/api/all.html#all_util_iserror_object">util.isError(object)</a> </dt><dd>判断对象是否为Error对象.
</dd>

<dt> <a href="http://nodejs.org/docs/latest/api/all.html#all_additions_to_error_objects">Domain: Additions to Error objects</a> </dt><dd>在Error对象上附加额外的字段.
</dd>
</dl>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Error到底是何方神圣？</h2>
<div class="outline-text-2" id="text-1">
<p>
Error对象是在ECMAScript 5.1（于2011年7月发布）中 <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.11">定义</a> 的，是一个比较新的特性：
</p>

<blockquote>
<p>
Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.
</p>
</blockquote>

<p>
它只有两个属性：
</p>

<dl class="org-dl">
<dt> name </dt><dd>错误名称，默认为"Error"
</dd>

<dt> message </dt><dd>错误消息，默认为""
</dd>
</dl>

<p>
V8实现了一个扩展属性：
</p>

<dl class="org-dl">
<dt> stack </dt><dd>错误描述及调用堆栈 
</dd>
</dl>

<p>
它只有一个方法：
</p>

<dl class="org-dl">
<dt> toString </dt><dd>转成字符串形式，通常为 "name: message"
</dd>
</dl>

<p>
构造一个Error实例：
</p>

<p>
new Error(message) 或者 Error(message)，两者是一样的。
</p>

<p>
示例：显示错误消息
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err);
console.log(err.toString());
console.log(err.message);
</pre>
</div>

<p>
需要注意的是console.log(JSON.stringify(err))显示的是空对象{}.
</p>

<p>
示例：显示错误消息及调用堆栈
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err.stack);
</pre>
</div>

<p>
示例：显示错误名称
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err.name);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">如何自定义Error类型？</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">function</span> <span style="color: #de935f;">MyError</span>(<span style="color: #f0c674;">message</span>) {
<span style="background-color: #373b41;"> </span> <span style="color: #81a2be;">this</span>.message = message || <span style="color: #8abeb7;">''</span>;
}

MyError.<span style="color: #81a2be;">prototype</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Error</span>();
MyError.<span style="color: #81a2be;">prototype</span>.constructor = MyError;
MyError.<span style="color: #81a2be;">prototype</span>.name = <span style="color: #8abeb7;">'MyError'</span>;
</pre>
</div>

<p>
Error实例类型判断
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">err</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Error</span>(<span style="color: #8abeb7;">"this is error"</span>);
<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">myerr</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">MyError</span>(<span style="color: #8abeb7;">"this is my error"</span>);
err <span style="color: #b5bd68;">instanceof</span> <span style="color: #81a2be;">Error</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">true*/</span>
err <span style="color: #b5bd68;">instanceof</span> <span style="color: #81a2be;">MyError</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">false*/</span>
myerr <span style="color: #b5bd68;">instanceof</span> <span style="color: #81a2be;">MyError</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">true*/</span>
myerr <span style="color: #b5bd68;">instanceof</span> <span style="color: #81a2be;">Error</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">true*/</span>
</pre>
</div>

<p>
stack输出有问题：自定义的错误描述没了
</p>

<div class="org-src-container">

<pre class="src src-js">err.stack <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">'Error: this is error\n    at repl:1:11 ...*/</span>
myerr.stack <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">'MyError\n    at repl:1:21 ...*/</span>
</pre>
</div>

<p>
修复node.js下MyError的stack不正确的问题
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">function</span> <span style="color: #de935f;">MyError</span>(<span style="color: #f0c674;">message</span>) {
<span style="background-color: #373b41;"> </span> Error.captureStackTrace(<span style="color: #81a2be;">this</span>, <span style="color: #81a2be;">this</span>.constructor)
<span style="background-color: #373b41;"> </span> <span style="color: #81a2be;">this</span>.message = message || <span style="color: #8abeb7;">''</span>;
}

MyError.<span style="color: #81a2be;">prototype</span> = <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">Error</span>();
MyError.<span style="color: #81a2be;">prototype</span>.constructor = MyError;
MyError.<span style="color: #81a2be;">prototype</span>.name = <span style="color: #8abeb7;">'MyError'</span>;
</pre>
</div>

<p>
<b>最终版：更node.js化一些</b>
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">function</span> <span style="color: #de935f;">MyError</span>(<span style="color: #f0c674;">message</span>) {
<span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">if</span> (!(<span style="color: #81a2be;">this</span> <span style="color: #b5bd68;">instanceof</span> <span style="color: #81a2be;">MyError</span>)) {
<span style="background-color: #373b41;"> </span>   <span style="background-color: #373b41;"> </span>   <span style="color: #b5bd68;">return</span> <span style="color: #b5bd68;">new</span> <span style="color: #81a2be;">MyError</span>(message);
<span style="background-color: #373b41;"> </span>   }
<span style="background-color: #373b41;"> </span>   Error.captureStackTrace(<span style="color: #81a2be;">this</span>, <span style="color: #81a2be;">this</span>.constructor)
<span style="background-color: #373b41;"> </span>   <span style="color: #81a2be;">this</span>.message = message || <span style="color: #8abeb7;">''</span>;
}

util.inherits(MyError, Error)
MyError.<span style="color: #81a2be;">prototype</span>.name = <span style="color: #8abeb7;">'MyError'</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">参考</h2>
<div class="outline-text-2" id="text-3">
<dl class="org-dl">
<dt> <a href="https://docs.nodejitsu.com/articles/errors/what-is-the-error-object">What is the error object?</a> </dt><dd>对Error对象的成员有所提及，但与当前的node.js版本不一致。
</dd>

<dt> <a href="https://cnodejs.org/topic/52090bc944e76d216af25f6f">Node.js下自定义错误类型</a> </dt><dd>教你如何自定义错误类型。
</dd>

<dt> <a href="http://stackoverflow.com/questions/10624873/what-properties-does-nodejs-expresss-error-object-exposes">What properties does nodejs express's Error object exposes?</a> </dt><dd>讨论Error对象相关属性
</dd>

<dt> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">MDN &gt; Web technology for developers &gt; JavaScript &gt; JavaScript reference &gt; Standard built-in objects &gt; Error</a> </dt><dd>Error对象参考文档
</dd>

<dt> <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.11">Error Objects</a> </dt><dd>Error对象标准文档
</dd>
</dl>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[编译安装node.js]]></title>
            <link>/article/7f168bd15b8988c5-node.js.html</link>
            <guid>/article/7f168bd15b8988c5-node.js.html</guid>
            <pubDate>Mon, 17 Feb 2014 08:23:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>下载

<p>
node.js是一个新兴的开发平台，版本更新非常活跃，因此应该尽量下载安装最新的版本。
</p>

<p>
到 <a href="http://nodejs.org/">http://nodejs.org/</a> 下载最新的版本。
</p>
</li>

<li>安装

<p>
解压后参照 README.md 进行安装：
</p>

<div class="org-src-container">

<pre class="src src-sh">./configure
make
make install
</pre>
</div>
</li>

<li>安装后

<p>
默认安装到/usr/local。
</p>

<dl class="org-dl">
<dt> /usr/local/bin/node </dt><dd>node主程序
</dd>
<dt> /usr/local/bin/npm </dt><dd>node模块管理程序
</dd>
<dt> /usr/local/lib/node_modules </dt><dd>node全局模块目录
</dd>
</dl>
<p>
像一些需要全局安装的模块也会把文件安装在/usr/local目录下。
</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[express.js中如何在第一次请求的响应中取得connect.sid]]></title>
            <link>/article/express.js-4e2d59824f5557287b2c4e006b218bf76c42768454cd5e944e2d53d65f97-connect.sid.html</link>
            <guid>/article/express.js-4e2d59824f5557287b2c4e006b218bf76c42768454cd5e944e2d53d65f97-connect.sid.html</guid>
            <pubDate>Fri, 14 Feb 2014 15:34:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
在web页面通过iframe跨域登录访问服务的情况下，是不方便取cookie中的sessionid的，于是想到将sessionid直接放到响应体中，
这就需要在node.js中直接获取connect.sid这个cookie值，一开始想当然地以为系统（使用的是passport.js）会在登录认证通过后
执行res.cookie('connect.sid', &#x2026;)进行设置，就想直接从res的Set-Cookie头解析出设置的值，结果发现这个cookie压根不存在，
甚至在库代码中搜索cookie都不管用，着实急得人直抓头。最后dump出res后确在req中见到了connect.sid值的影子：req.sessionID，
然后在 <a href="http://stackoverflow.com/questions/13693101/express-sessionid-differs-from-sessionid-in-cookie">《Express SessionID differs from SessionID in Cookie》</a> 中找到了从req.sessionID计算出connect.sid的方法：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">signature</span> = require(<span style="color: #8abeb7;">'express/node_modules/cookie-signature'</span>);
<span style="color: #b5bd68;">var</span> <span style="color: #f0c674;">connectSid</span> = <span style="color: #8abeb7;">'s:'</span> + signature.sign(req.sessionID, sessionOptions.secret);
</pre>
</div>

<p>
其实，connect.sid这个cookie是在请求到来后在req上设置的（不存在则设置），不管有没有登录都会设置。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[node.js下访问mysql注意事项]]></title>
            <link>/article/node.js-4e0b8bbf95ee-mysql-6ce8610f4e8b9879.html</link>
            <guid>/article/node.js-4e0b8bbf95ee-mysql-6ce8610f4e8b9879.html</guid>
            <pubDate>Fri, 11 Oct 2013 02:45:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
本文仅针对 <a href="https://github.com/felixge/node-mysql">node-mysql</a> 模块。
</p>

<ul class="org-ul">
<li>Connection 对象为一个到mysql的连接，在其上的query是串行进行的。

<p>
由于mysql协议类似http是串行的，在一个mysql连接上的多个query必须依次进行。
</p>

<p>
<a href="https://github.com/felixge/node-mysql">node-mysql</a> 的 Connection对象上同时发起的多个query会队列化，
</p>

<p>
处理完一个query再进行下一query的处理，传递给回调函数的query结果不会错乱。
</p>

<p>
在有一定访问量的服务中应该总是使用 <code>连接池</code> 。
</p>
</li>
</ul>


<ul class="org-ul">
<li>处理Connection对象的重连。

<p>
mysql连接空闲一段时间后（默认8小时）会自动关闭，
</p>

<p>
可以在Connection对象的 <code>error</code> 事件中检测后连接断开时进行重连。
</p>

<p>
使用 <code>连接池</code> 不会有问题，连接断开后会默认从连接池中剔除。</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《理解Node.js》培训课件]]></title>
            <link>/article/300a740689e3-node.js-300b57f98bad8bfe4ef6.html</link>
            <guid>/article/300a740689e3-node.js-300b57f98bad8bfe4ef6.html</guid>
            <pubDate>Thu, 04 Jul 2013 10:31:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
本课件介绍Node.js的特点及其初步使用。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">开发计划 <code>[1/3]</code></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><code>[X]</code> 编写大纲
</li>
<li><code>[&#xa0;]</code> 编写内容
</li>
<li><code>[&#xa0;]</code> 制作Microsoft PowerPoint格式文档
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">在线演示</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="http://blog.kankanan.com/slides/%E7%90%86%E8%A7%A3Node.js.html">《理解Node.js》</a></p>
</div>
</div>
]]></content:encoded>
        </item>
    </channel>
</rss>