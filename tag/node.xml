<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>node - 看看俺 – KanKanAn.com</title>
        <description>记我所思，忆我所为。</description>
        <link>http://blog.kankanan.com/tag/node.xml</link>
        <lastBuildDate>Tue, 24 Nov 2015 08:03:08 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <image>
            <title>node - 看看俺 – KanKanAn.com</title>
            <url>http://blog.kankanan.com/static/favicon.ico</url>
            <link>http://blog.kankanan.com/tag/node.xml</link>
        </image>
        <copyright>版权所有 © 2011-2015 看看俺 – KanKanAn.com</copyright>
        <generator>Feed for Node.js</generator>
        <category>技术</category>
        <item>
            <title><![CDATA[node.js应用错误处理]]></title>
            <link>/article/node.js-5e94752895198bef59047406.html</link>
            <guid>/article/node.js-5e94752895198bef59047406.html</guid>
            <pubDate>Fri, 30 Oct 2015 10:08:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
先看一个简单的示例：
</p>

<div class="org-src-container">

<pre class="src src-js">app.post(<span style="color: #66cccc;">'/products'</span>, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">req</span>, <span style="color: #ffcc66;">res</span>) {
<span style="background-color: #515151;"> </span>   service.add(req.body, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">err</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   logger.error(err.toString());
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.statusCode = 500;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span> res.end({error: err.message});
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.statusCode = 200;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.end();
<span style="background-color: #515151;"> </span>   });
}};
</pre>
</div>

<p>
上面的代码能够直接用于产品环境吗？
</p>

<p>
对于稍微严谨的产品，答案肯定是 <span class="underline">否</span> 。
</p>

<p>
针对 service.add 调用失败提两个疑问：
</p>

<ul class="org-ul">
<li>如何根据错误类型给客户端返回不同的响应，以便客户端更人性化（而非简单的弹消息框）？
</li>

<li>err.message 会不会包含不应该给用户看到的信息？
</li>
</ul>

<p>
我们需要规范化错误类型，进行明确的分类标识，直到最外层的代码能够根据错误对象提供的信息，给客户端返回恰当的响应，
下面是我能想到的一些基本原则：
</p>

<ul class="org-ul">
<li>错误对象拥有统一的接口

<p>
确保错误对象是一个Error类实例，如需要自定义错误类型，从Error类继承。
</p>
</li>

<li>对错误进行命名标识

<p>
重量级的做法：为每一个错误类型自定义一个错误类。
轻量级的做法：将Error对象的name属性设置为错误类型标识。
</p>
</li>

<li>在恰当的层次将底层Error对象转化为自定义的错误对象

<p>
对底层返回的原始错误，尽可能在调用栈恰当的层次转化为合适应用层错误对象，但不必强制对所有底层错误进行转换，
原生的Error对象可以认为是未标识的错误，这种错误可以默认处理（如：给客户端返回HTTP 500错误）。
</p>
</li>
</ul>

<p>
错误进行分类标识后的使用示例：
</p>

<div class="org-src-container">

<pre class="src src-js">app.post(<span style="color: #66cccc;">'/products'</span>, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">req</span>, <span style="color: #ffcc66;">res</span>) {
<span style="background-color: #515151;"> </span>   service.add(req.body, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">err</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   logger.error(err.toString());
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err.name === <span style="color: #66cccc;">'ProductAlreadyExists'</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.statusCode = 400;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   } <span style="color: #99cc99;">else</span> {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   err.message = <span style="color: #66cccc;">'&#20869;&#37096;&#38169;&#35823;'</span>;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.statusCode = 500;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span> res.end({error: err.message});
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.statusCode = 200;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   res.end();
<span style="background-color: #515151;"> </span>   });
}};
</pre>
</div>

<p>
优雅的错误处理是系统可维护性的重要组成部分，它和代码各部分息息相关，系统成型后很难再引入错误处理，设计系统时应该一开始就将它纳入考虑范围。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">参考</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>《<a href="https://www.joyent.com/developers/node/design/errors">Error Handling in Nodejs - Developer Center - Joyent</a>》

<p>
来自Joyent的Node.js错误处理最佳实践
</p>
</li>

<li>《<a href="https://cnodejs.org/topic/52090bc944e76d216af25f6f">Node.js下自定义错误类型 - CNode</a>》

<p>
派生Error类注意事项
</p>
</li>

<li>《<a href="https://docs.nodejitsu.com/articles/errors/what-is-the-error-object">What is the error object? - docs.nodejitsu.com</a>》

<p>
Error对象详解
</p>
</li>

<li>《<a href="http://www.bennadel.com/blog/2828-creating-custom-error-objects-in-node-js-with-error-capturestacktrace.htm">Creating Custom Error Objects In Node.js With Error.captureStackTrace()</a>》

<p>
直接可用的自定义Error类方案
</p>
</li>

<li><a href="https://github.com/jayyvis/extend-error">extend-error</a>

<p>
用于扩展Error类的node.js模块
</p>
</li>

<li><a href="https://github.com/davepacheco/node-verror">node-verror</a>

<p>
包裹原始Error对象，并且保证可访问性的node.js模块，Joyent的Node.js错误处理最佳实践中进行了推荐
</p>
</li>

<li>《<a href="https://github.com/davepacheco/node-verror/issues/15">Support for custom error types? · Issue #15 · davepacheco/node-verror</a>》

<p>
<a href="https://github.com/davepacheco/node-verror">node-verror</a> 支持扩展的讨论</p>
</li>
</ul>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[process.exit导致的控制台输出不全]]></title>
            <link>/article/process.exit-5bfc81f4768463a7523653f08f9351fa4e0d5168.html</link>
            <guid>/article/process.exit-5bfc81f4768463a7523653f08f9351fa4e0d5168.html</guid>
            <pubDate>Thu, 27 Aug 2015 09:03:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>先上案例程序：

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">for</span>(<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">i</span> = 0; i &lt; 10000; ++i) {
<span style="background-color: #515151;"> </span>   console.log(<span style="color: #66cccc;">"this is long long long long long long long long long long long </span><span style="color: #66cccc; text-decoration: underline;">long long long long long long long long long long long long long long long long long long log "</span><span style="text-decoration: underline;"> + i);</span>
}
process.exit(0);
</pre>
</div>

<p>
这个程序输出10000行日志，然后结束进程。
</p>
</li>

<li><code>Emacs Shell</code> 以及 <code>GNOME Terminal</code> 下运行结果（省略中间部分输出）：

<pre class="example">
$ node /home/tangxinfa/Examples/test_exit.js
this is long long long long long long long long long long long long long long long long long long long long long long long long long long long long long log 0
...
this is long long long long long long long long long long long long long long long long long long long long long long long long long long long long long log 119
$
</pre>

<p>
程序只输出了前面200行日志。
</p>
</li>

<li>按 <code>Ctrl+Alt+F2</code> 进入2号系统终端下运行结果（省略中间部分输出）：

<pre class="example">
$ node /home/tangxinfa/Examples/test_exit.js
this is long long long long long long long long long long long long long long long long long long long long long long long long long long long long long log 0
...
this is long long long long long long long long long long long long long long long long long long long long long long long long long long long long long log 9999
$
</pre>

<p>
程序输出了完整的日志。
</p>
</li>

<li>日志重定向到文件时 <code>Emacs Shell</code> 以及 <code>GNOME Terminal</code> 下运行结果（省略中间部分输出）：

<pre class="example">
$ node /home/tangxinfa/Examples/test_exit.js &gt; /tmp/test_exit.log
$ tail -1 /tmp/test_exit.log
this is long long long long long long long long long long long long long long long long long long long long long long long long long long long long long log 9999
$
</pre>

<p>
程序输出了完整的日志。
</p>
</li>

<li>原因

<p>
如果输出目标为终端（ <code>Emacs Shell</code> 以及 <code>GNOME Terminal</code> 并非真正的终端）或文件时，console函数是同步的（避免程序过早退出导致丢消息），目标为管道时则为异步（避免长时间堵塞）。
</p>

<blockquote>
<p>
The console functions are synchronous when the destination is a terminal or a file (to avoid lost messages in case of premature exit) and asynchronous when it's a pipe (to avoid blocking for long periods of time).
</p>
</blockquote>

<p>
参考：《<a href="http://stackoverflow.com/questions/18748164/process-exit0-output-disappears">process.exit(0): output disappears?</a>》
</p>
</li>

<li>解决方案

<p>
调用 <code>process.exit</code> 时确保输出完毕，封装如下：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #999999; font-style: italic;">/// </span><span style="color: #999999; font-style: italic;">Safe exit. Makesure log output flushed to console.</span>
<span style="color: #99cc99;">function</span> <span style="color: #f99157;">exit</span>(<span style="color: #ffcc66;">code</span>) {
<span style="background-color: #515151;"> </span>   process.stdout.write(<span style="color: #66cccc;">''</span>, <span style="color: #99cc99;">function</span> () {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   process.stderr.write(<span style="color: #66cccc;">''</span>, <span style="color: #99cc99;">function</span> () {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   process.exit(code);
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   });
<span style="background-color: #515151;"> </span>   });
}
</pre>
</div>

<p>
注意，上面的 <code>exit</code> 函数不会像 <code>process.exit</code> 一样立即终止程序，请将 <code>process.exit</code> 替换为  <code>return exit</code> 。</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[linux服务器出现大量CLOSE_WAIT状态的连接]]></title>
            <link>/article/linux-670d52a1566851fa73b0592791cf-close_wait-72b6600176848fde63a5.html</link>
            <guid>/article/linux-670d52a1566851fa73b0592791cf-close_wait-72b6600176848fde63a5.html</guid>
            <pubDate>Sat, 01 Aug 2015 19:21:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
昨天服务器停止服务，node.js进程耗光了服务器的内存及CPU，node.js进程卡死无法被 <code>kill</code> 掉，最后要来root帐号密码，直接 <code>kill -9</code> 才结束掉进程。
</p>

<p>
再次鄙视一下 <a href="https://github.com/nodejitsu/forever">forever</a> ，杀不掉原来的 node.js 进程组也就罢了，竟然又拉起了一套新的 node.js 进程组。
</p>

<p>
统计了一下 <code>10</code> 万个fd都耗光了，其中 <code>9</code> 万多个为 <code>CLOSE_WAIT</code> 状态，此时服务器已经无法响应请求。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">CLOSE_WAIT 状态介绍</h2>
<div class="outline-text-2" id="text-1">
<p>
先看一副TCP连接关闭的状态图（ <a href="http://intronetworks.cs.luc.edu/current/html/tcp.html#index-29">来源</a> ）：
</p>


<div class="figure">
<p><img src="../static/tcp_normal_close.png" alt="tcp_normal_close.png" />
</p>
</div>

<p>
被动关闭一方才会出现 <code>CLOSE_WAIT</code> 状态，由于被动关闭方未调用 <code>close</code> 关闭socket导致，问题肯定是由服务器代码引起。
</p>

<p>
检测到对端socket关闭然后关闭本端socket是由 node.js 自行完成的，最大的可能是没有机会执行 <code>close</code> 。
</p>

<p>
我们的应用客户端与服务器有一个tls长连接，当连接断开时客户端会等待3-10秒后尝试重连服务器，如果服务器出现卡顿会导致客户端频繁重连，
</p>

<p>
如果服务器来不及关闭这些连接，则会出现 CLOSE_WAIT 状态的连接，占用大量文件描述符，减少 CLOSE_WAIT 超时时间能够在一定程度上缓解这个问题，
</p>

<p>
但是对于我们这种长连接的环境，大量CLOSE_WAIT是问题的表象，而非根源。
</p>

<p>
参考：《<a href="http://lvxuehu.iteye.com/blog/452487">解决CLOSE_WAIT 问题</a>》
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">内存及CPU占用彪升问题</h2>
<div class="outline-text-2" id="text-2">
<p>
伴随着 CLOSE_WAIT 出现的状况是 node.js 进程内存及CPU占用超高，单node.js进程内存占用达到 1.5G，CPU占用 90% 以上，此时应该会导致 node.js 响应慢，
来不及关闭连上来的socket。
</p>

<p>
所以解决问题的关键就是：找出什么原因导致 node.js 内存及CPU 100%占用。
</p>

<p>
想到的可能是redis负载过高引起，从运维监控图上可以看出一些蹊跷，node.js出问题时redis的连接数也同样彪升，而出问题的机器上刚好就是跑redis的机器，
另一台服务器一直相安无事，没有跑redis。
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">一次午夜故障元凶浮出水面</h2>
<div class="outline-text-2" id="text-3">
<p>
在晚上两点的时候服务出现问题，同样的现象，特别留意了一下redis的统计，请求速度很低，只有1200，平时都是5000。偶然在进程列表中发现了 redis-rdb-bgsave 的身影，
不断地执行ps看进程列表，发现 redis-rdb-bgsave 进程不断地出现，查看redis的持久化配置如下：
</p>

<pre class="example">
save 900 1
save 300 10
save 60 10000
</pre>

<p>
我们的系统有大量的redis，1分钟肯定过万，这样redis持久化变是常态了，而且由于用的是机械硬盘，持久化肯定会引起系统卡顿，先将它调整为15分钟最多持久化一次：
</p>

<pre class="example">
config set save "900 1"
</pre>

<p>
重启程序释放资源后系统开始正常响应，但是10多分钟后系统再次无响应，才想起一则经验教训：
</p>

<pre class="example">
     跑redis的机器至少要预留和redis占用内存同样大小的空闲内存空间，redis RDB持久化进行fork时最坏会占用双倍内存，内存不足就会动用交换分区，系统性能急剧下降。
</pre>

<p>
于是，立即改配置将redis所在机器上的node.js cluster进程数调小，腾出大把内存，总算没有再出现问题，今晚终于可以入眠。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">更多疑问</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>我们的node.js进程为什么常常会占用很多内存？
</li>

<li>netstat中看到CLOSE_WAIT状态的连接输入缓冲往往有数据，而ESTABLISHED状态的连接读写缓冲区往往为空，为什么？
</li>

<li>node.js卡顿时forever杀不死反而启动了新实例帮倒忙，pm2就一定能够解决吗？
</li>

<li>redis持久化引起服务挂掉，已经是在第二个项目中遇到了，终极解决方案是什么？
</li>
</ul>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[后台服务监护工具：forever与pm2]]></title>
            <link>/article/540e53f0670d52a176d162a45de55177ff1a-forever-4e0e-pm2.html</link>
            <guid>/article/540e53f0670d52a176d162a45de55177ff1a-forever-4e0e-pm2.html</guid>
            <pubDate>Fri, 24 Jul 2015 16:15:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
使用后台服务监护工具有很多好处：
</p>

<ul class="org-ul">
<li>程序崩溃时自动拉起
</li>

<li>程序日志聚合（你的系统有多个模块或多个进程的时候很有必要）
</li>

<li>代码更新时自动重启服务
</li>
</ul>

<p>
node.js下最常用的后台服务监护工具有：<a href="https://github.com/nodejitsu/forever">forever</a> 、<a href="https://github.com/Unitech/pm2">pm2</a> 。
</p>

<p>
<a href="https://github.com/nodejitsu/forever">forever</a> 先出现，<a href="https://github.com/Unitech/pm2">pm2</a> 后出现功能更丰富，下面是特性对比：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Feature</th>
<th scope="col" class="left">Forever</th>
<th scope="col" class="left">PM2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Keep Alive</td>
<td class="left">✔</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">Coffeescript</td>
<td class="left">✔</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Log aggregation</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">API</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">Terminal monitoring</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">Clustering</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">JSON configuration</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>
</tbody>
</table>

<p>
我在3个项目中使用 <a href="https://github.com/nodejitsu/forever">forever</a> ，多次重启出错后，决定转向 <a href="https://github.com/Unitech/pm2">pm2</a> ，目前我已经在两个较小的项目中成功使用 <a href="https://github.com/Unitech/pm2">pm2</a> 。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="https://github.com/nodejitsu/forever">forever</a></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>安装

<div class="org-src-container">

<pre class="src src-js">npm install -g forever
</pre>
</div>
</li>

<li>配置

<p>
启动脚本
<code>start.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #999999; font-style: italic;">#</span><span style="color: #999999; font-style: italic;">!/bin/</span><span style="color: #99cc99;">bash</span>

<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">PATH</span>=$<span style="color: #ffcc66;">PATH</span>:<span style="color: #cc99cc;">`pwd`</span>/node/bin:<span style="color: #cc99cc;">`pwd`</span>/../node/bin:<span style="color: #cc99cc;">`pwd`</span>/node_modules/forever/bi<span style="text-decoration: underline;">n:/usr/local/node/bin</span>
<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">NODE_ENV</span>=${<span style="color: #ffcc66;">NODE_ENV</span>:-production}
<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">NODE_CONFIG_DIR</span>=<span style="color: #cc99cc;">`pwd`</span>/config

<span style="color: #ffcc66;">SCRIPT</span>=<span style="color: #cc99cc;">`pwd`</span>/src/index.js
<span style="color: #ffcc66;">LOGFILE</span>=<span style="color: #cc99cc;">`pwd`</span>/run.log

<span style="color: #ffcc66;">running</span>=<span style="color: #cc99cc;">`forever list | grep "$SCRIPT" | grep -v grep | wc -l`</span>

<span style="color: #99cc99;">if</span> [ $<span style="color: #ffcc66;">running</span> -lt 1 ]; <span style="color: #99cc99;">then</span>
<span style="background-color: #515151;"> </span>   forever start --spinSleepTime=10000 --killSignal=SIGINT --pidFile=<span style="color: #cc99cc;">`pwd`</span>/run.<span style="text-decoration: underline;">pid -l $</span><span style="color: #ffcc66; text-decoration: underline;">LOGFILE</span><span style="text-decoration: underline;"> -a -w --watchDirectory=</span><span style="color: #cc99cc; text-decoration: underline;">`pwd`</span><span style="text-decoration: underline;">/src --watchIgnore=</span><span style="color: #66cccc; text-decoration: underline;">".svn/*"</span><span style="text-decoration: underline;"> </span><span style="color: #66cccc; text-decoration: underline;">"$SCRIPT"</span>
<span style="background-color: #515151;"> </span>   <span style="color: #cc99cc;">echo</span> -e <span style="color: #66cccc;">"\nRunning."</span>
<span style="color: #99cc99;">else</span>
<span style="background-color: #515151;"> </span>   <span style="color: #cc99cc;">echo</span> -e <span style="color: #66cccc;">"\nAlready running."</span>
<span style="color: #99cc99;">fi</span>

forever list | grep <span style="color: #66cccc;">"$SCRIPT"</span>
</pre>
</div>

<p>
停止脚本
<code>stop.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #999999; font-style: italic;">#</span><span style="color: #999999; font-style: italic;">!/bin/</span><span style="color: #99cc99;">bash</span>

<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">PATH</span>=$<span style="color: #ffcc66;">PATH</span>:<span style="color: #cc99cc;">`pwd`</span>/node/bin:<span style="color: #cc99cc;">`pwd`</span>/../node/bin:<span style="color: #cc99cc;">`pwd`</span>/node_modules/forever/bi<span style="text-decoration: underline;">n:/usr/local/node/bin</span>

<span style="color: #ffcc66;">SCRIPT</span>=<span style="color: #cc99cc;">`pwd`</span>/src/index.js

forever stop <span style="color: #66cccc;">"$SCRIPT"</span>
</pre>
</div>

<p>
重启脚本     
<code>restart.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #999999; font-style: italic;">#</span><span style="color: #999999; font-style: italic;">!/bin/</span><span style="color: #99cc99;">bash</span>

<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">PATH</span>=$<span style="color: #ffcc66;">PATH</span>:<span style="color: #cc99cc;">`pwd`</span>/node/bin:<span style="color: #cc99cc;">`pwd`</span>/../node/bin:<span style="color: #cc99cc;">`pwd`</span>/node_modules/forever/bi<span style="text-decoration: underline;">n:/usr/local/node/bin</span>

<span style="color: #ffcc66;">SCRIPT</span>=<span style="color: #cc99cc;">`pwd`</span>/src/index.js

forever restart <span style="color: #66cccc;">"$SCRIPT"</span> || ./start.sh
</pre>
</div>
</li>

<li>用法

<p>
启动
</p>

<div class="org-src-container">

<pre class="src src-sh">./start.sh
</pre>
</div>

<p>
停止
</p>

<div class="org-src-container">

<pre class="src src-sh">./stop.sh
</pre>
</div>

<p>
重启
</p>

<div class="org-src-container">

<pre class="src src-sh">./restart.sh
</pre>
</div>
</li>

<li>缺点

<ul class="org-ul">
<li>程序退出过程中的日志无法捕获

<p>
参见：<a href="https://github.com/foreverjs/forever/issues/385#issuecomment-115163346">no logging after graceful shutdown #385</a>
</p>

<p>
应该是forever通过信号通知程序退出后，不再捕获程序的日志输出，程序退出的这段时间内日志丢失。
</p>

<p>
一个补丁方案：程序收到forever的退出信号后将日志直接写到日志文件（正常情况下是由forever捕获程序的错误输出写日志文件）。
</p>
</li>

<li>重启可能失败

<p>
代码更新后，forever会发信号重启进程，但是程序始终重启不成功，出现大量下面的日志：
</p>
<pre class="example">
Error: bind EADDRINUSE
</pre>

<p>
怀疑跟node.js的cluster中master自动拉起slave的行为相冲突，此时只有一个forever实例在运行，这种情况占比很高。
</p>

<p>
另外crontab中调用start.sh也可能和forever相冲突，当node全退出时，可能启动多个forever实例，这种情况占比稍低。
</p>

<p>
另外一种情况是node.js出问题了CPU及内存100%占用，此时普通的kill杀不死（必须得kill -9），forever误认为已成功结束node.js进程，
然后拉起新的进程。
</p>
</li>

<li>未内置支持开机启动

<p>
可以直接放在crontab每分钟调用一次 <code>start.sh</code> 来实现，万一连forever进程都挂了，可以全部拉起来。
开机启动不内置则意味着一百个人有一百种做法，带来不必要的争议。
</p>
</li>

<li>允许程序同时启动多个实例

<p>
forever未对启动的程序进行唯一性标识，导致程序可能意外启动多个实例，多个实例之间往往相冲突，降低了系统可用性。
</p>

<p>
而由程序自已来实现单实例运行是很困难的，forever会不断地拉起退出的多余副本。
</p>
</li>

<li>未内置支持cluster以及优雅重启

<p>
部署代码重启程序过程中会停止服务几秒钟。
</p>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><a href="https://github.com/Unitech/pm2">pm2</a></h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>安装

<div class="org-src-container">

<pre class="src src-js">npm install -g pm2
</pre>
</div>
</li>

<li>配置

<p>
以 <a href="https://github.com/tangxinfa/upload-fiddle">upload-fiddle</a> 项目为例。
</p>

<p>
统一配置其它脚本需要的环境变量
<code>.bashrc</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">PATH</span>=<span style="color: #cc99cc;">`pwd`</span>/node/bin:<span style="color: #cc99cc;">`pwd`</span>/../node/bin:<span style="color: #cc99cc;">`pwd`</span>/node_modules/pm2/bin:/usr/loc<span style="text-decoration: underline;">al/node/bin:$</span><span style="color: #ffcc66; text-decoration: underline;">PATH</span>
<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">NODE_ENV</span>=${<span style="color: #ffcc66;">NODE_ENV</span>:-production}
<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">NODE_CONFIG_DIR</span>=<span style="color: #cc99cc;">`pwd`</span>/config
<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">APP_NAME</span>=<span style="color: #66cccc;">"upload-fiddle"</span>
<span style="color: #cc99cc;">export</span> <span style="color: #ffcc66;">APP_SCRIPT</span>=<span style="color: #cc99cc;">`pwd`</span>/src/index.js
</pre>
</div>

<p>
启动脚本
<code>start.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #999999; font-style: italic;">#</span><span style="color: #999999; font-style: italic;">!/bin/</span><span style="color: #99cc99;">bash</span>

<span style="color: #cc99cc;">source</span> .bashrc
pm2 --node-args=<span style="color: #66cccc;">"--harmony"</span> -n <span style="color: #66cccc;">"$APP_NAME"</span> start <span style="color: #66cccc;">"$APP_SCRIPT"</span> -i 0 --watch <span style="color: #66cccc;">"`pw</span><span style="color: #66cccc; text-decoration: underline;">d`/src/*.js"</span>
</pre>
</div>

<p>
停止脚本
<code>stop.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #999999; font-style: italic;">#</span><span style="color: #999999; font-style: italic;">!/bin/</span><span style="color: #99cc99;">bash</span>

<span style="color: #cc99cc;">source</span> .bashrc
pm2 --node-args=<span style="color: #66cccc;">"--harmony"</span> stop <span style="color: #66cccc;">"$APP_NAME"</span>
</pre>
</div>

<p>
重启脚本
<code>restart.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #999999; font-style: italic;">#</span><span style="color: #999999; font-style: italic;">!/bin/</span><span style="color: #99cc99;">bash</span>

<span style="color: #cc99cc;">source</span> .bashrc
pm2 --node-args=<span style="color: #66cccc;">"--harmony"</span> restart <span style="color: #66cccc;">"$APP_NAME"</span>
</pre>
</div>
</li>

<li>用法

<p>
启动
</p>

<div class="org-src-container">

<pre class="src src-sh">./start.sh
</pre>
</div>

<p>
停止
</p>

<div class="org-src-container">

<pre class="src src-sh">./stop.sh
</pre>
</div>

<p>
重启
</p>

<div class="org-src-container">

<pre class="src src-sh">./restart.sh
</pre>
</div>
</li>

<li>缺点

<ul class="org-ul">
<li>程序退出过程中的日志无法捕获？

<p>
不一定。使用 <code>pm2 stop</code> 会有同样的问题，但是pm2支持优雅退出（ <code>pm2 gracefulReload</code> ），此时不但退出过程中的日志能够正常捕获，而且可以实现服务0停机时间。
</p>
</li>

<li>重启可能失败

<p>
是的。=pm2 restart= 并没有采用激进的措施（kill -9）确保旧进程结束。重现步骤：用gdb调试运行中的node进程（gdb node &lt;PID&gt;后不执行任何gdb命令），然后用pm2 restart重启服务，此时旧的进程杀不死，新的进程被创建。
</p>
</li>

<li>允许程序同时启动多个实例

<p>
pm2对启动的程序进行了唯一性标识，但是它将启动的信息保存在了当前用户的home目录下（~/.pm2），所以使用其它帐号时还是有能够启动多个程序实例，对于这一点forever也存在同样的问题。
</p>

<p>
对于服务器来说，多帐号是常态，应该默认防止这种问题发生。
</p>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">程序写日志相关</h2>
<div class="outline-text-2" id="text-3">
<p>
用c/c++写日志的时候我一般都会使用日志库，如：<a href="http://logging.apache.org/log4cxx/index.html">log4cxx</a> 、<a href="https://github.com/HardySimpson/zlog">zlog</a> ，这些日志库容易使用而且很稳定，支持将日志写到文件或控制台，支持按大小、日期分割日志文件，支持限定日志文件数、占用空间。
</p>

<p>
但是node.js下最好的写日志方式其实是将日志直接输出到错误输出（stderr），由 <a href="https://github.com/nodejitsu/forever">forever</a> 、<a href="https://github.com/Unitech/pm2">pm2</a> 这样的后台服务监护工具来写日志文件。这是因为node.js做为一种动态语言，容易出现异常，特别是前期开发阶段，很多分支没有跑到，往往是写日志的语句出错，此时日志库是很难做到将异常时程序的调用堆栈写到日志文件中的，由台后服务监护工具来做能确保万无一失。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>《<a href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/">告别node-forever,拥抱PM2</a>》
</li>
</ul>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用node.js的对象模式验证模块joi引入强类型]]></title>
            <link>/article/4f7f7528-node.js-76845bf98c616a215f0f9a8c8bc16a215757-joi-5f1551655f3a7c7b578b.html</link>
            <guid>/article/4f7f7528-node.js-76845bf98c616a215f0f9a8c8bc16a215757-joi-5f1551655f3a7c7b578b.html</guid>
            <pubDate>Mon, 13 Jul 2015 10:44:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>弱类型的Javascript

<p>
Javascript是一门弱类型的语言，定义变量不需要指定类型，可以为同一个变量赋任意类型的值。误用类型不会报错，而结果会让你大吃一惊：
</p>

<pre class="example">
&gt; "1" + 1
'11'
&gt; if ("false") { console.log("yes") } else { console.log("no"); }
yes
undefined
&gt;
</pre>

<p>
redis中很多数据结构取出时都是字符串值（如：set、hash），调用方需要自行将它转换成正确的类型（如：Boolean、Date、Number），如果不转换成正确的类型会导致冗长的代码，如Boolean类型：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">if</span> ((String(model.stoped) == <span style="color: #66cccc;">'true'</span>)) {
<span style="background-color: #515151;"> </span>   <span style="color: #999999; font-style: italic;">// </span><span style="color: #999999; font-style: italic;">Do something when stoped.</span>
}
</pre>
</div>

<p>
如果手工转换成正确的类型肯定要写很多样板代码了。
</p>
</li>

<li>对象模式验证模块 <a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a>

<p>
有很多的ORM（ Object Relational Mapping 对象关系映射）库都能够实现强类型的数据模型，但是它们都相当的复杂，支持各种各样的数据库后端，支持一对一、一对多、多对多等数据关系，但是很少支持分表分库，我们的系统一般是数据模型简单但要考虑用户量大了横向扩展，所以一开始就进行了分表分库，无法使用重型的ORM。
</p>

<p>
如果有一个能够自动根据模式（Schema）定义对值进行类型转换的库，一定会非常有用。
</p>

<p>
<a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a> 一个Javascript对象模式描述语言以及验证（Object schema description language and validator for JavaScript objects）的库，它可以完成对象类型转换以及合法性验证。
</p>
</li>

<li><a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a> 的用法示例

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">joi</span> = require(<span style="color: #66cccc;">'joi'</span>);
<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">redis</span> = require(<span style="color: #66cccc;">'redis'</span>);

<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">client</span> = redis.createClient(6379, <span style="color: #66cccc;">'127.0.0.1'</span>);

<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">User</span> = <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">options</span>) {
<span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (! options) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   options = {};
<span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   <span style="color: #6699cc;">this</span>.id = options.id || 0;
<span style="background-color: #515151;"> </span>   <span style="color: #6699cc;">this</span>.name = options.name || <span style="color: #66cccc;">''</span>;
<span style="background-color: #515151;"> </span>   <span style="color: #6699cc;">this</span>.male = options.male || <span style="color: #6699cc;">true</span>;
<span style="background-color: #515151;"> </span>   <span style="color: #6699cc;">this</span>.birthday = options.birthday;
};

User.schema = joi.object().keys({
<span style="background-color: #515151;"> </span>   id: joi.number().integer().min(1),
<span style="background-color: #515151;"> </span>   name: joi.string().required(),
<span style="background-color: #515151;"> </span>   male: joi.<span style="color: #6699cc;">boolean</span>().<span style="color: #99cc99;">default</span>(<span style="color: #6699cc;">true</span>),
<span style="background-color: #515151;"> </span>   birthday: joi.date().required()
});

User.find = <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">id</span>, <span style="color: #ffcc66;">callback</span>) {
<span style="background-color: #515151;"> </span>   client.hgetall(<span style="color: #66cccc;">"user:"</span> + id, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">err</span>, <span style="color: #ffcc66;">value</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span> callback(err);
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   } <span style="color: #99cc99;">else</span> <span style="color: #99cc99;">if</span> (! value) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span> callback(<span style="color: #99cc99;">new</span> <span style="color: #6699cc;">Error</span>(<span style="color: #66cccc;">"User not found"</span>));
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   joi.validate(value, User.schema, callback);
<span style="background-color: #515151;"> </span>   });
};

User.<span style="color: #6699cc;">prototype</span>.save = <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">callback</span>) {
<span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">value</span> = {};
<span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">for</span>(<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">fieldName</span> <span style="color: #99cc99;">in</span> <span style="color: #6699cc;">this</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (<span style="color: #99cc99;">typeof</span>(<span style="color: #6699cc;">this</span>[fieldName]) != <span style="color: #66cccc;">'function'</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   value[fieldName] = <span style="color: #6699cc;">this</span>[fieldName];
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }
<span style="background-color: #515151;"> </span>   }
<span style="background-color: #515151;"> </span>   joi.validate(value, User.schema, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">err</span>, <span style="color: #ffcc66;">validatedValue</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span> callback(err);
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   client.hmset(<span style="color: #66cccc;">"user:"</span> + validatedValue.id, validatedValue, callback);
<span style="background-color: #515151;"> </span>   });
};


<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">user</span> = <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">User</span>({
<span style="background-color: #515151;"> </span>   id: 1,
<span style="background-color: #515151;"> </span>   name: <span style="color: #66cccc;">"txf"</span>,
<span style="background-color: #515151;"> </span>   male: <span style="color: #6699cc;">true</span>,
<span style="background-color: #515151;"> </span>   birthday: <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">Date</span>(<span style="color: #66cccc;">"1983-03-22"</span>)
});

user.save(<span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">err</span>) {
<span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   console.error(<span style="color: #66cccc;">"user save error("</span> + err.toString() + <span style="color: #66cccc;">")"</span>);
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   client.quit();
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span>;
<span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   console.info(<span style="color: #66cccc;">"user saved"</span>);

<span style="background-color: #515151;"> </span>   User.find(user.id, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">err</span>, <span style="color: #ffcc66;">user</span>) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   client.quit();
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (err) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   console.error(<span style="color: #66cccc;">"user find error("</span> + err.toString() + <span style="color: #66cccc;">")"</span>);
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span>;
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   }

<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   console.log(<span style="color: #66cccc;">"user found: "</span> + JSON.stringify(user));
<span style="background-color: #515151;"> </span>   });
});
</pre>
</div>

<p>
运行结果：
</p>

<div class="org-src-container">

<pre class="src src-js">user saved
user found: {<span style="color: #66cccc;">"id"</span>:1,<span style="color: #66cccc;">"name"</span>:<span style="color: #66cccc;">"txf"</span>,<span style="color: #66cccc;">"male"</span>:<span style="color: #6699cc;">true</span>,<span style="color: #66cccc;">"birthday"</span>:<span style="color: #66cccc;">"1983-03-22T00:00:00.000</span><span style="color: #66cccc; text-decoration: underline;">Z"</span><span style="text-decoration: underline;">}</span>
</pre>
</div>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Node.js服务器TCP死连接问题诊断]]></title>
            <link>/article/node.js-670d52a15668-tcp-6b7b8fde63a595ee98988bca65ad.html</link>
            <guid>/article/node.js-670d52a15668-tcp-6b7b8fde63a595ee98988bca65ad.html</guid>
            <pubDate>Thu, 16 Apr 2015 12:29:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
最近一段时间，由于开发工作开始跟嵌入式相关，开始遇到一个问题：TCP死连接。
</p>

<p>
TCP死连接症状是这样的：通信双方从一方系统上看已经断开（不存在），但是另一方系统上看却是连接中（ESTABLISHED状态）。
</p>

<p>
TCP死连接一般在一方（或中间线路上的设备）断电、死机后出现，此时由于另一方收不到断开连接的IP报文，会认为连接仍然存在，日积月累会耗光文件描述符空间从而导致性能下降，最终拒绝服务。
</p>

<p>
对付这种问题，一般需要双方都进行连接心跳检测。比如：连接空闲一段时间后一方发一个心跳请求，另一端回个心跳响应，心跳请求发送方一段时间后还收不到响应则认为连接已断开，心跳请求接收方一段时间内没有收到心跳请求也认为连接已断开。
</p>

<p>
需要注意到的是node.js的tls服务器端握手超时处理不当可能会导致TCP死连接出现，有问题的代码示例如下：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">options</span> = {
<span style="background-color: #515151;"> </span>   key: <span style="color: #66cccc;">"..."</span>,
<span style="background-color: #515151;"> </span>   cert: <span style="color: #66cccc;">"..."</span>,
<span style="background-color: #515151;"> </span>   handshakeTimeout: 10*1000,
<span style="background-color: #515151;"> </span>   plain: <span style="color: #6699cc;">true</span>,
<span style="background-color: #515151;"> </span>   ssl: <span style="color: #6699cc;">true</span>
};

<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">tlsServer</span> = tls.createServer(options, app).listen(5433, 8192, <span style="color: #99cc99;">function</span>(){
<span style="background-color: #515151;"> </span>   logger.log(<span style="color: #66cccc;">'tls server listening on port 5433'</span>);
});

tlsServer.on(<span style="color: #66cccc;">'clientError'</span>, <span style="color: #99cc99;">function</span> (<span style="color: #ffcc66;">exception</span>, <span style="color: #ffcc66;">socket</span>) {
<span style="background-color: #515151;"> </span>   logger.warn(<span style="color: #66cccc;">'tls server client('</span> + socket.remoteAddress + <span style="color: #66cccc;">':'</span> + socket.remot<span style="text-decoration: underline;">ePort +</span><span style="color: #66cccc; text-decoration: underline;">') error('</span><span style="text-decoration: underline;"> + exception + </span><span style="color: #66cccc; text-decoration: underline;">')'</span><span style="text-decoration: underline;">);</span>
});
</pre>
</div>

<p>
上面的代码通过指定 <code>handshakeTimeout</code> 使用指定SSL握手超时时间，但是并未关闭底层的TCP连接，从而导致TCP连接泄露，在 <code>clientError</code> 事件处理函数中添加以下释放语句即可：
</p>

<div class="org-src-container">

<pre class="src src-js">socket.destroy();
</pre>
</div>

<p>
除了常见的断电、死机引起TCP死连接外，这里还有一个论坛帖子论坛其它原因：《<a href="http://serverfault.com/questions/504187/too-many-established-connections-left-open">Too many established connections left open</a>》。
</p>

<p>
另外还有 linux 内核的 tcp keepalive机制作为心跳解决方案：《<a href="http://machael.blog.51cto.com/829462/211989/">linux下使用TCP存活(keepalive)定时器</a>》。
</p>

<p>
谨记：除了主动通过连接发送数据外，其它情况下操作系统可能不会告诉你连接已经关闭了。
</p>

<p>
要彻底解决这个问题，除了要避免泄露（或忘记关闭）TCP连接外，要有心跳机制，还需要从代码层面进行防御性编程，如：对于读写操作设置超时时间，一旦超时主动关闭连接。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[理解node.js中的Error对象]]></title>
            <link>/article/740689e3-node.js-4e2d7684-error-5bf98c61.html</link>
            <guid>/article/740689e3-node.js-4e2d7684-error-5bf98c61.html</guid>
            <pubDate>Tue, 09 Dec 2014 05:38:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
Error对象在 <a href="http://nodejs.org">node.js</a> 程序中无处不在，但是关于它在 <a href="http://nodejs.org/docs/latest/api/all.html">node.js文档</a> （写这篇文章时node.js的最新版本为v0.10.33）中却找不到描述资料，只在以下部分提及：
</p>

<dl class="org-dl">
<dt> <a href="http://nodejs.org/docs/latest/api/all.html#all_util_iserror_object">util.isError(object)</a> </dt><dd>判断对象是否为Error对象.
</dd>

<dt> <a href="http://nodejs.org/docs/latest/api/all.html#all_additions_to_error_objects">Domain: Additions to Error objects</a> </dt><dd>在Error对象上附加额外的字段.
</dd>
</dl>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Error到底是何方神圣？</h2>
<div class="outline-text-2" id="text-1">
<p>
Error对象是在ECMAScript 5.1（于2011年7月发布）中 <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.11">定义</a> 的，是一个比较新的特性：
</p>

<blockquote>
<p>
Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.
</p>
</blockquote>

<p>
它只有两个属性：
</p>

<dl class="org-dl">
<dt> name </dt><dd>错误名称，默认为"Error"
</dd>

<dt> message </dt><dd>错误消息，默认为""
</dd>
</dl>

<p>
V8实现了一个扩展属性：
</p>

<dl class="org-dl">
<dt> stack </dt><dd>错误描述及调用堆栈 
</dd>
</dl>

<p>
它只有一个方法：
</p>

<dl class="org-dl">
<dt> toString </dt><dd>转成字符串形式，通常为 "name: message"
</dd>
</dl>

<p>
构造一个Error实例：
</p>

<p>
new Error(message) 或者 Error(message)，两者是一样的。
</p>

<p>
示例：显示错误消息
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err);
console.log(err.toString());
console.log(err.message);
</pre>
</div>

<p>
需要注意的是console.log(JSON.stringify(err))显示的是空对象{}.
</p>

<p>
示例：显示错误消息及调用堆栈
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err.stack);
</pre>
</div>

<p>
示例：显示错误名称
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err.name);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">如何自定义Error类型？</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">function</span> <span style="color: #f99157;">MyError</span>(<span style="color: #ffcc66;">message</span>) {
<span style="background-color: #515151;"> </span> <span style="color: #6699cc;">this</span>.message = message || <span style="color: #66cccc;">''</span>;
}

MyError.<span style="color: #6699cc;">prototype</span> = <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">Error</span>();
MyError.<span style="color: #6699cc;">prototype</span>.constructor = MyError;
MyError.<span style="color: #6699cc;">prototype</span>.name = <span style="color: #66cccc;">'MyError'</span>;
</pre>
</div>

<p>
Error实例类型判断
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">err</span> = <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">Error</span>(<span style="color: #66cccc;">"this is error"</span>);
<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">myerr</span> = <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">MyError</span>(<span style="color: #66cccc;">"this is my error"</span>);
err <span style="color: #99cc99;">instanceof</span> <span style="color: #6699cc;">Error</span> <span style="color: #999999; font-style: italic;">/*</span><span style="color: #999999; font-style: italic;">true*/</span>
err <span style="color: #99cc99;">instanceof</span> <span style="color: #6699cc;">MyError</span> <span style="color: #999999; font-style: italic;">/*</span><span style="color: #999999; font-style: italic;">false*/</span>
myerr <span style="color: #99cc99;">instanceof</span> <span style="color: #6699cc;">MyError</span> <span style="color: #999999; font-style: italic;">/*</span><span style="color: #999999; font-style: italic;">true*/</span>
myerr <span style="color: #99cc99;">instanceof</span> <span style="color: #6699cc;">Error</span> <span style="color: #999999; font-style: italic;">/*</span><span style="color: #999999; font-style: italic;">true*/</span>
</pre>
</div>

<p>
stack输出有问题：自定义的错误描述没了
</p>

<div class="org-src-container">

<pre class="src src-js">err.stack <span style="color: #999999; font-style: italic;">/*</span><span style="color: #999999; font-style: italic;">'Error: this is error\n    at repl:1:11 ...*/</span>
myerr.stack <span style="color: #999999; font-style: italic;">/*</span><span style="color: #999999; font-style: italic;">'MyError\n    at repl:1:21 ...*/</span>
</pre>
</div>

<p>
修复node.js下MyError的stack不正确的问题
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">function</span> <span style="color: #f99157;">MyError</span>(<span style="color: #ffcc66;">message</span>) {
<span style="background-color: #515151;"> </span> Error.captureStackTrace(<span style="color: #6699cc;">this</span>, <span style="color: #6699cc;">this</span>.constructor)
<span style="background-color: #515151;"> </span> <span style="color: #6699cc;">this</span>.message = message || <span style="color: #66cccc;">''</span>;
}

MyError.<span style="color: #6699cc;">prototype</span> = <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">Error</span>();
MyError.<span style="color: #6699cc;">prototype</span>.constructor = MyError;
MyError.<span style="color: #6699cc;">prototype</span>.name = <span style="color: #66cccc;">'MyError'</span>;
</pre>
</div>

<p>
<b>最终版：更node.js化一些</b>
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">function</span> <span style="color: #f99157;">MyError</span>(<span style="color: #ffcc66;">message</span>) {
<span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">if</span> (!(<span style="color: #6699cc;">this</span> <span style="color: #99cc99;">instanceof</span> <span style="color: #6699cc;">MyError</span>)) {
<span style="background-color: #515151;"> </span>   <span style="background-color: #515151;"> </span>   <span style="color: #99cc99;">return</span> <span style="color: #99cc99;">new</span> <span style="color: #6699cc;">MyError</span>(message);
<span style="background-color: #515151;"> </span>   }
<span style="background-color: #515151;"> </span>   Error.captureStackTrace(<span style="color: #6699cc;">this</span>, <span style="color: #6699cc;">this</span>.constructor)
<span style="background-color: #515151;"> </span>   <span style="color: #6699cc;">this</span>.message = message || <span style="color: #66cccc;">''</span>;
}

util.inherits(MyError, Error)
MyError.<span style="color: #6699cc;">prototype</span>.name = <span style="color: #66cccc;">'MyError'</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">参考</h2>
<div class="outline-text-2" id="text-3">
<dl class="org-dl">
<dt> <a href="https://docs.nodejitsu.com/articles/errors/what-is-the-error-object">What is the error object?</a> </dt><dd>对Error对象的成员有所提及，但与当前的node.js版本不一致。
</dd>

<dt> <a href="https://cnodejs.org/topic/52090bc944e76d216af25f6f">Node.js下自定义错误类型</a> </dt><dd>教你如何自定义错误类型。
</dd>

<dt> <a href="http://stackoverflow.com/questions/10624873/what-properties-does-nodejs-expresss-error-object-exposes">What properties does nodejs express's Error object exposes?</a> </dt><dd>讨论Error对象相关属性
</dd>

<dt> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">MDN &gt; Web technology for developers &gt; JavaScript &gt; JavaScript reference &gt; Standard built-in objects &gt; Error</a> </dt><dd>Error对象参考文档
</dd>

<dt> <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.11">Error Objects</a> </dt><dd>Error对象标准文档
</dd>
</dl>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[编译安装node.js]]></title>
            <link>/article/7f168bd15b8988c5-node.js.html</link>
            <guid>/article/7f168bd15b8988c5-node.js.html</guid>
            <pubDate>Mon, 17 Feb 2014 08:23:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>下载

<p>
node.js是一个新兴的开发平台，版本更新非常活跃，因此应该尽量下载安装最新的版本。
</p>

<p>
到 <a href="http://nodejs.org/">http://nodejs.org/</a> 下载最新的版本。
</p>
</li>

<li>安装

<p>
解压后参照 README.md 进行安装：
</p>

<div class="org-src-container">

<pre class="src src-sh">./configure
make
make install
</pre>
</div>
</li>

<li>安装后

<p>
默认安装到/usr/local。
</p>

<dl class="org-dl">
<dt> /usr/local/bin/node </dt><dd>node主程序
</dd>
<dt> /usr/local/bin/npm </dt><dd>node模块管理程序
</dd>
<dt> /usr/local/lib/node_modules </dt><dd>node全局模块目录
</dd>
</dl>
<p>
像一些需要全局安装的模块也会把文件安装在/usr/local目录下。
</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[express.js中如何在第一次请求的响应中取得connect.sid]]></title>
            <link>/article/express.js-4e2d59824f5557287b2c4e006b218bf76c42768454cd5e944e2d53d65f97-connect.sid.html</link>
            <guid>/article/express.js-4e2d59824f5557287b2c4e006b218bf76c42768454cd5e944e2d53d65f97-connect.sid.html</guid>
            <pubDate>Fri, 14 Feb 2014 15:34:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
在web页面通过iframe跨域登录访问服务的情况下，是不方便取cookie中的sessionid的，于是想到将sessionid直接放到响应体中，
这就需要在node.js中直接获取connect.sid这个cookie值，一开始想当然地以为系统（使用的是passport.js）会在登录认证通过后
执行res.cookie('connect.sid', &#x2026;)进行设置，就想直接从res的Set-Cookie头解析出设置的值，结果发现这个cookie压根不存在，
甚至在库代码中搜索cookie都不管用，着实急得人直抓头。最后dump出res后确在req中见到了connect.sid值的影子：req.sessionID，
然后在 <a href="http://stackoverflow.com/questions/13693101/express-sessionid-differs-from-sessionid-in-cookie">《Express SessionID differs from SessionID in Cookie》</a> 中找到了从req.sessionID计算出connect.sid的方法：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">signature</span> = require(<span style="color: #66cccc;">'express/node_modules/cookie-signature'</span>);
<span style="color: #99cc99;">var</span> <span style="color: #ffcc66;">connectSid</span> = <span style="color: #66cccc;">'s:'</span> + signature.sign(req.sessionID, sessionOptions.secret);
</pre>
</div>

<p>
其实，connect.sid这个cookie是在请求到来后在req上设置的（不存在则设置），不管有没有登录都会设置。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[node.js下访问mysql注意事项]]></title>
            <link>/article/node.js-4e0b8bbf95ee-mysql-6ce8610f4e8b9879.html</link>
            <guid>/article/node.js-4e0b8bbf95ee-mysql-6ce8610f4e8b9879.html</guid>
            <pubDate>Fri, 11 Oct 2013 02:45:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
本文仅针对 <a href="https://github.com/felixge/node-mysql">node-mysql</a> 模块。
</p>

<ul class="org-ul">
<li>Connection 对象为一个到mysql的连接，在其上的query是串行进行的。

<p>
由于mysql协议类似http是串行的，在一个mysql连接上的多个query必须依次进行。
</p>

<p>
<a href="https://github.com/felixge/node-mysql">node-mysql</a> 的 Connection对象上同时发起的多个query会队列化，
</p>

<p>
处理完一个query再进行下一query的处理，传递给回调函数的query结果不会错乱。
</p>

<p>
在有一定访问量的服务中应该总是使用 <code>连接池</code> 。
</p>
</li>
</ul>


<ul class="org-ul">
<li>处理Connection对象的重连。

<p>
mysql连接空闲一段时间后（默认8小时）会自动关闭，
</p>

<p>
可以在Connection对象的 <code>error</code> 事件中检测后连接断开时进行重连。
</p>

<p>
使用 <code>连接池</code> 不会有问题，连接断开后会默认从连接池中剔除。</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《理解Node.js》培训课件]]></title>
            <link>/article/300a740689e3-node.js-300b57f98bad8bfe4ef6.html</link>
            <guid>/article/300a740689e3-node.js-300b57f98bad8bfe4ef6.html</guid>
            <pubDate>Thu, 04 Jul 2013 10:31:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
本课件介绍Node.js的特点及其初步使用。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">开发计划 <code>[1/3]</code></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><code>[X]</code> 编写大纲
</li>
<li><code>[&#xa0;]</code> 编写内容
</li>
<li><code>[&#xa0;]</code> 制作Microsoft PowerPoint格式文档
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">在线演示</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="http://blog.kankanan.com/slides/%E7%90%86%E8%A7%A3Node.js.html">《理解Node.js》</a></p>
</div>
</div>
]]></content:encoded>
        </item>
    </channel>
</rss>