<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>node - 看看俺 – KanKanAn.com</title>
        <description>记我所思，忆我所为。</description>
        <link>http://blog.kankanan.com/tag/node.xml</link>
        <lastBuildDate>Fri, 24 Jul 2015 16:18:58 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <image>
            <title>node - 看看俺 – KanKanAn.com</title>
            <url>http://blog.kankanan.com/static/favicon.ico</url>
            <link>http://blog.kankanan.com/tag/node.xml</link>
        </image>
        <copyright>版权所有 © 2011-2015 看看俺 – KanKanAn.com</copyright>
        <generator>Feed for Node.js</generator>
        <category>技术</category>
        <item>
            <title><![CDATA[后台服务监护工具：forever与pm2]]></title>
            <link>/article/540e53f0670d52a176d162a45de55177ff1a-forever-4e0e-pm2.html</link>
            <guid>/article/540e53f0670d52a176d162a45de55177ff1a-forever-4e0e-pm2.html</guid>
            <pubDate>Fri, 24 Jul 2015 16:15:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
使用后台服务监护工具有很多好处：
</p>

<ul class="org-ul">
<li>程序崩溃时自动拉起
</li>

<li>程序日志聚合（你的系统有多个模块或多个进程的时候很有必要）
</li>

<li>代码更新时自动重启服务
</li>
</ul>

<p>
node.js下最常用的后台服务监护工具有：<a href="https://github.com/nodejitsu/forever">forever</a> 、<a href="https://github.com/Unitech/pm2">pm2</a> 。
</p>

<p>
<a href="https://github.com/nodejitsu/forever">forever</a> 先出现，<a href="https://github.com/Unitech/pm2">pm2</a> 后出现功能更丰富，下面是特性对比：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Feature</th>
<th scope="col" class="left">Forever</th>
<th scope="col" class="left">PM2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">Keep Alive</td>
<td class="left">✔</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">Coffeescript</td>
<td class="left">✔</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Log aggregation</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">API</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">Terminal monitoring</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">Clustering</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>

<tr>
<td class="left">JSON configuration</td>
<td class="left">&#xa0;</td>
<td class="left">✔</td>
</tr>
</tbody>
</table>

<p>
我在3个项目中使用 <a href="https://github.com/nodejitsu/forever">forever</a> ，多次重启出错后，决定转向 <a href="https://github.com/Unitech/pm2">pm2</a> ，目前我已经在两个较小的项目中成功使用 <a href="https://github.com/Unitech/pm2">pm2</a> 。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><a href="https://github.com/nodejitsu/forever">forever</a></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>安装

<div class="org-src-container">

<pre class="src src-js">npm install -g forever
</pre>
</div>
</li>

<li>配置

<p>
启动脚本
<code>start.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #969896; font-style: italic;">#</span><span style="color: #969896; font-style: italic;">!/bin/</span><span style="color: #b9ca4a;">bash</span>

<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">PATH</span>=$<span style="color: #e7c547;">PATH</span>:<span style="color: #c397d8;">`pwd`</span>/node/bin:<span style="color: #c397d8;">`pwd`</span>/../node/bin:<span style="color: #c397d8;">`pwd`</span>/node_modules/forever/bi<span style="text-decoration: underline;">n:/usr/local/node/bin</span>
<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">NODE_ENV</span>=${<span style="color: #e7c547;">NODE_ENV</span>:-production}
<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">NODE_CONFIG_DIR</span>=<span style="color: #c397d8;">`pwd`</span>/config

<span style="color: #e7c547;">SCRIPT</span>=<span style="color: #c397d8;">`pwd`</span>/src/index.js
<span style="color: #e7c547;">LOGFILE</span>=<span style="color: #c397d8;">`pwd`</span>/run.log

<span style="color: #e7c547;">running</span>=<span style="color: #c397d8;">`forever list | grep "$SCRIPT" | grep -v grep | wc -l`</span>

<span style="color: #b9ca4a;">if</span> [ $<span style="color: #e7c547;">running</span> -lt 1 ]; <span style="color: #b9ca4a;">then</span>
<span style="background-color: #424242;"> </span>   forever start --spinSleepTime=10000 --killSignal=SIGINT --pidFile=<span style="color: #c397d8;">`pwd`</span>/run.<span style="text-decoration: underline;">pid -l $</span><span style="color: #e7c547; text-decoration: underline;">LOGFILE</span><span style="text-decoration: underline;"> -a -w --watchDirectory=</span><span style="color: #c397d8; text-decoration: underline;">`pwd`</span><span style="text-decoration: underline;">/src --watchIgnore=</span><span style="color: #70c0b1; text-decoration: underline;">".svn/*"</span><span style="text-decoration: underline;"> </span><span style="color: #70c0b1; text-decoration: underline;">"$SCRIPT"</span>
<span style="background-color: #424242;"> </span>   <span style="color: #c397d8;">echo</span> -e <span style="color: #70c0b1;">"\nRunning."</span>
<span style="color: #b9ca4a;">else</span>
<span style="background-color: #424242;"> </span>   <span style="color: #c397d8;">echo</span> -e <span style="color: #70c0b1;">"\nAlready running."</span>
<span style="color: #b9ca4a;">fi</span>

forever list | grep <span style="color: #70c0b1;">"$SCRIPT"</span>
</pre>
</div>

<p>
停止脚本
<code>stop.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #969896; font-style: italic;">#</span><span style="color: #969896; font-style: italic;">!/bin/</span><span style="color: #b9ca4a;">bash</span>

<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">PATH</span>=$<span style="color: #e7c547;">PATH</span>:<span style="color: #c397d8;">`pwd`</span>/node/bin:<span style="color: #c397d8;">`pwd`</span>/../node/bin:<span style="color: #c397d8;">`pwd`</span>/node_modules/forever/bi<span style="text-decoration: underline;">n:/usr/local/node/bin</span>

<span style="color: #e7c547;">SCRIPT</span>=<span style="color: #c397d8;">`pwd`</span>/src/index.js

forever stop <span style="color: #70c0b1;">"$SCRIPT"</span>
</pre>
</div>

<p>
重启脚本     
<code>restart.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #969896; font-style: italic;">#</span><span style="color: #969896; font-style: italic;">!/bin/</span><span style="color: #b9ca4a;">bash</span>

<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">PATH</span>=$<span style="color: #e7c547;">PATH</span>:<span style="color: #c397d8;">`pwd`</span>/node/bin:<span style="color: #c397d8;">`pwd`</span>/../node/bin:<span style="color: #c397d8;">`pwd`</span>/node_modules/forever/bi<span style="text-decoration: underline;">n:/usr/local/node/bin</span>

<span style="color: #e7c547;">SCRIPT</span>=<span style="color: #c397d8;">`pwd`</span>/src/index.js

forever restart <span style="color: #70c0b1;">"$SCRIPT"</span> || ./start.sh
</pre>
</div>
</li>

<li>用法

<p>
启动
</p>

<div class="org-src-container">

<pre class="src src-sh">./start.sh
</pre>
</div>

<p>
停止
</p>

<div class="org-src-container">

<pre class="src src-sh">./stop.sh
</pre>
</div>

<p>
重启
</p>

<div class="org-src-container">

<pre class="src src-sh">./restart.sh
</pre>
</div>
</li>

<li>缺点

<ul class="org-ul">
<li>程序退出过程中的日志无法捕获

<p>
参见：<a href="https://github.com/foreverjs/forever/issues/385#issuecomment-115163346">no logging after graceful shutdown #385</a>
</p>

<p>
应该是forever通过信号通知程序退出后，不再捕获程序的日志输出，程序退出的这段时间内日志丢失。
</p>

<p>
一个补丁方案：程序收到forever的退出信号后将日志直接写到日志文件（正常情况下是由forever捕获程序的错误输出写日志文件）。
</p>
</li>

<li>重启可能失败

<p>
代码更新后，forever会发信号重启进程，但是程序始终重启不成功，出现大量下面的日志：
</p>
<pre class="example">
Error: bind EADDRINUSE
</pre>

<p>
怀疑跟node.js的cluster中master自动拉起slave的行为相冲突，此时只有一个forever实例在运行，这种情况占比很高。
</p>

<p>
另外crontab中调用start.sh也可能和forever相冲突，当node全退出时，可能启动多个forever实例，这种情况占比稍低。
</p>
</li>

<li>未内置支持开机启动

<p>
可以直接放在crontab每分钟调用一次 <code>start.sh</code> 来实现，万一连forever进程都挂了，可以全部拉起来。
开机启动不内置则意味着一百个人有一百种做法，带来不必要的争议。
</p>
</li>

<li>允许程序同时启动多个实例

<p>
forever未对启动的程序进行唯一性标识，导致程序可能意外启动多个实例，多个实例之间往往相冲突，降低了系统可用性。
</p>

<p>
而由程序自已来实现单实例运行是很困难的，forever会不断地拉起退出的多余副本。
</p>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><a href="https://github.com/Unitech/pm2">pm2</a></h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li>安装

<div class="org-src-container">

<pre class="src src-js">npm install -g pm2
</pre>
</div>
</li>

<li>配置

<p>
以 <a href="https://github.com/tangxinfa/upload-fiddle">upload-fiddle</a> 项目为例。
</p>

<p>
统一配置其它脚本需要的环境变量
<code>.bashrc</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #c397d8;">export</span> <span style="color: #e7c547;">PATH</span>=<span style="color: #c397d8;">`pwd`</span>/node/bin:<span style="color: #c397d8;">`pwd`</span>/../node/bin:<span style="color: #c397d8;">`pwd`</span>/node_modules/pm2/bin:/usr/loc<span style="text-decoration: underline;">al/node/bin:$</span><span style="color: #e7c547; text-decoration: underline;">PATH</span>
<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">NODE_ENV</span>=${<span style="color: #e7c547;">NODE_ENV</span>:-production}
<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">NODE_CONFIG_DIR</span>=<span style="color: #c397d8;">`pwd`</span>/config
<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">APP_NAME</span>=<span style="color: #70c0b1;">"upload-fiddle"</span>
<span style="color: #c397d8;">export</span> <span style="color: #e7c547;">APP_SCRIPT</span>=<span style="color: #c397d8;">`pwd`</span>/src/index.js
</pre>
</div>

<p>
启动脚本
<code>start.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #969896; font-style: italic;">#</span><span style="color: #969896; font-style: italic;">!/bin/</span><span style="color: #b9ca4a;">bash</span>

<span style="color: #c397d8;">source</span> .bashrc
pm2 --node-args=<span style="color: #70c0b1;">"--harmony"</span> -n <span style="color: #70c0b1;">"$APP_NAME"</span> start <span style="color: #70c0b1;">"$APP_SCRIPT"</span> -i 0 --watch <span style="color: #70c0b1;">"`pw</span><span style="color: #70c0b1; text-decoration: underline;">d`/src/*.js"</span>
</pre>
</div>

<p>
停止脚本
<code>stop.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #969896; font-style: italic;">#</span><span style="color: #969896; font-style: italic;">!/bin/</span><span style="color: #b9ca4a;">bash</span>

<span style="color: #c397d8;">source</span> .bashrc
pm2 --node-args=<span style="color: #70c0b1;">"--harmony"</span> stop <span style="color: #70c0b1;">"$APP_NAME"</span>
</pre>
</div>

<p>
重启脚本
<code>restart.sh</code>
</p>
<div class="org-src-container">

<pre class="src src-sh"><span style="color: #969896; font-style: italic;">#</span><span style="color: #969896; font-style: italic;">!/bin/</span><span style="color: #b9ca4a;">bash</span>

<span style="color: #c397d8;">source</span> .bashrc
pm2 --node-args=<span style="color: #70c0b1;">"--harmony"</span> restart <span style="color: #70c0b1;">"$APP_NAME"</span>
</pre>
</div>
</li>

<li>用法

<p>
启动
</p>

<div class="org-src-container">

<pre class="src src-sh">./start.sh
</pre>
</div>

<p>
停止
</p>

<div class="org-src-container">

<pre class="src src-sh">./stop.sh
</pre>
</div>

<p>
重启
</p>

<div class="org-src-container">

<pre class="src src-sh">./restart.sh
</pre>
</div>
</li>

<li>缺点

<ul class="org-ul">
<li>允许程序同时启动多个实例

<p>
pm2对启动的程序进行了唯一性标识，但是它将启动的信息保存在了当前用户的home目录下（~/.pm2），所以使用其它帐号时还是有能够启动多个程序实例，对于这一点forever也存在同样的问题。
</p>

<p>
对于服务器来说，多帐号是常态，应该默认防止这种问题发生。
</p>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">程序写日志相关</h2>
<div class="outline-text-2" id="text-3">
<p>
用c/c++写日志的时候我一般都会使用日志库，如：<a href="http://logging.apache.org/log4cxx/index.html">log4cxx</a> 、<a href="https://github.com/HardySimpson/zlog">zlog</a> ，这些日志库容易使用而且很稳定，支持将日志写到文件或控制台，支持按大小、日期分割日志文件，支持限定日志文件数、占用空间。
</p>

<p>
但是node.js下最好的写日志方式其实是将日志直接输出到错误输出（stderr），由 <a href="https://github.com/nodejitsu/forever">forever</a> 、<a href="https://github.com/Unitech/pm2">pm2</a> 这样的后台服务监护工具来写日志文件。这是因为node.js做为一种动态语言，容易出现异常，特别是前期开发阶段，很多分支没有跑到，往往是写日志的语句出错，此时日志库是很难做到将异常时程序的调用堆栈写到日志文件中的，由台后服务监护工具来做能确保万无一失。
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">参考</h2>
<div class="outline-text-2" id="text-4">
<ul class="org-ul">
<li>《<a href="http://se77en.cc/2013/06/27/goodbye-node-forever-hello-pm2-translation/">告别node-forever,拥抱PM2</a>》
</li>
</ul>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[使用node.js的对象模式验证模块joi引入强类型]]></title>
            <link>/article/4f7f7528-node.js-76845bf98c616a215f0f9a8c8bc16a215757-joi-5f1551655f3a7c7b578b.html</link>
            <guid>/article/4f7f7528-node.js-76845bf98c616a215f0f9a8c8bc16a215757-joi-5f1551655f3a7c7b578b.html</guid>
            <pubDate>Mon, 13 Jul 2015 10:44:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>弱类型的Javascript

<p>
Javascript是一门弱类型的语言，定义变量不需要指定类型，可以为同一个变量赋任意类型的值。误用类型不会报错，而结果会让你大吃一惊：
</p>

<pre class="example">
&gt; "1" + 1
'11'
&gt; if ("false") { console.log("yes") } else { console.log("no"); }
yes
undefined
&gt;
</pre>

<p>
redis中很多数据结构取出时都是字符串值（如：set、hash），调用方需要自行将它转换成正确的类型（如：Boolean、Date、Number），如果不转换成正确的类型会导致冗长的代码，如Boolean类型：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">if</span> ((String(model.stoped) == <span style="color: #70c0b1;">'true'</span>)) {
<span style="background-color: #424242;"> </span>   <span style="color: #969896; font-style: italic;">// </span><span style="color: #969896; font-style: italic;">Do something when stoped.</span>
}
</pre>
</div>

<p>
如果手工转换成正确的类型肯定要写很多样板代码了。
</p>
</li>

<li>对象模式验证模块 <a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a>

<p>
有很多的ORM（ Object Relational Mapping 对象关系映射）库都能够实现强类型的数据模型，但是它们都相当的复杂，支持各种各样的数据库后端，支持一对一、一对多、多对多等数据关系，但是很少支持分表分库，我们的系统一般是数据模型简单但要考虑用户量大了横向扩展，所以一开始就进行了分表分库，无法使用重型的ORM。
</p>

<p>
如果有一个能够自动根据模式（Schema）定义对值进行类型转换的库，一定会非常有用。
</p>

<p>
<a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a> 一个Javascript对象模式描述语言以及验证（Object schema description language and validator for JavaScript objects）的库，它可以完成对象类型转换以及合法性验证。
</p>
</li>

<li><a href="https://github.com/hapijs/joi#anydefaultvalue-description">joi</a> 的用法示例

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">joi</span> = require(<span style="color: #70c0b1;">'joi'</span>);
<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">redis</span> = require(<span style="color: #70c0b1;">'redis'</span>);

<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">client</span> = redis.createClient(6379, <span style="color: #70c0b1;">'127.0.0.1'</span>);

<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">User</span> = <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">options</span>) {
<span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (! options) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   options = {};
<span style="background-color: #424242;"> </span>   }

<span style="background-color: #424242;"> </span>   <span style="color: #7aa6da;">this</span>.id = options.id || 0;
<span style="background-color: #424242;"> </span>   <span style="color: #7aa6da;">this</span>.name = options.name || <span style="color: #70c0b1;">''</span>;
<span style="background-color: #424242;"> </span>   <span style="color: #7aa6da;">this</span>.male = options.male || <span style="color: #7aa6da;">true</span>;
<span style="background-color: #424242;"> </span>   <span style="color: #7aa6da;">this</span>.birthday = options.birthday;
};

User.schema = joi.object().keys({
<span style="background-color: #424242;"> </span>   id: joi.number().integer().min(1),
<span style="background-color: #424242;"> </span>   name: joi.string().required(),
<span style="background-color: #424242;"> </span>   male: joi.<span style="color: #7aa6da;">boolean</span>().<span style="color: #b9ca4a;">default</span>(<span style="color: #7aa6da;">true</span>),
<span style="background-color: #424242;"> </span>   birthday: joi.date().required()
});

User.find = <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">id</span>, <span style="color: #e7c547;">callback</span>) {
<span style="background-color: #424242;"> </span>   client.hgetall(<span style="color: #70c0b1;">"user:"</span> + id, <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">err</span>, <span style="color: #e7c547;">value</span>) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (err) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">return</span> callback(err);
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   } <span style="color: #b9ca4a;">else</span> <span style="color: #b9ca4a;">if</span> (! value) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">return</span> callback(<span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">Error</span>(<span style="color: #70c0b1;">"User not found"</span>));
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   }

<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   joi.validate(value, User.schema, callback);
<span style="background-color: #424242;"> </span>   });
};

User.<span style="color: #7aa6da;">prototype</span>.save = <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">callback</span>) {
<span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">value</span> = {};
<span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">for</span>(<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">fieldName</span> <span style="color: #b9ca4a;">in</span> <span style="color: #7aa6da;">this</span>) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (<span style="color: #b9ca4a;">typeof</span>(<span style="color: #7aa6da;">this</span>[fieldName]) != <span style="color: #70c0b1;">'function'</span>) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   value[fieldName] = <span style="color: #7aa6da;">this</span>[fieldName];
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   }
<span style="background-color: #424242;"> </span>   }
<span style="background-color: #424242;"> </span>   joi.validate(value, User.schema, <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">err</span>, <span style="color: #e7c547;">validatedValue</span>) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (err) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">return</span> callback(err);
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   }

<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   client.hmset(<span style="color: #70c0b1;">"user:"</span> + validatedValue.id, validatedValue, callback);
<span style="background-color: #424242;"> </span>   });
};


<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">user</span> = <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">User</span>({
<span style="background-color: #424242;"> </span>   id: 1,
<span style="background-color: #424242;"> </span>   name: <span style="color: #70c0b1;">"txf"</span>,
<span style="background-color: #424242;"> </span>   male: <span style="color: #7aa6da;">true</span>,
<span style="background-color: #424242;"> </span>   birthday: <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">Date</span>(<span style="color: #70c0b1;">"1983-03-22"</span>)
});

user.save(<span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">err</span>) {
<span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (err) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   console.error(<span style="color: #70c0b1;">"user save error("</span> + err.toString() + <span style="color: #70c0b1;">")"</span>);
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   client.quit();
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">return</span>;
<span style="background-color: #424242;"> </span>   }

<span style="background-color: #424242;"> </span>   console.info(<span style="color: #70c0b1;">"user saved"</span>);

<span style="background-color: #424242;"> </span>   User.find(user.id, <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">err</span>, <span style="color: #e7c547;">user</span>) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   client.quit();
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (err) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   console.error(<span style="color: #70c0b1;">"user find error("</span> + err.toString() + <span style="color: #70c0b1;">")"</span>);
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">return</span>;
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   }

<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   console.log(<span style="color: #70c0b1;">"user found: "</span> + JSON.stringify(user));
<span style="background-color: #424242;"> </span>   });
});
</pre>
</div>

<p>
运行结果：
</p>

<div class="org-src-container">

<pre class="src src-js">user saved
user found: {<span style="color: #70c0b1;">"id"</span>:1,<span style="color: #70c0b1;">"name"</span>:<span style="color: #70c0b1;">"txf"</span>,<span style="color: #70c0b1;">"male"</span>:<span style="color: #7aa6da;">true</span>,<span style="color: #70c0b1;">"birthday"</span>:<span style="color: #70c0b1;">"1983-03-22T00:00:00.000</span><span style="color: #70c0b1; text-decoration: underline;">Z"</span><span style="text-decoration: underline;">}</span>
</pre>
</div>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Node.js服务器TCP死连接问题诊断]]></title>
            <link>/article/node.js-670d52a15668-tcp-6b7b8fde63a595ee98988bca65ad.html</link>
            <guid>/article/node.js-670d52a15668-tcp-6b7b8fde63a595ee98988bca65ad.html</guid>
            <pubDate>Thu, 16 Apr 2015 12:29:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
最近一段时间，由于开发工作开始跟嵌入式相关，开始遇到一个问题：TCP死连接。
</p>

<p>
TCP死连接症状是这样的：通信双方从一方系统上看已经断开（不存在），但是另一方系统上看却是连接中（ESTABLISHED状态）。
</p>

<p>
TCP死连接一般在一方（或中间线路上的设备）断电、死机后出现，此时由于另一方收不到断开连接的IP报文，会认为连接仍然存在，日积月累会耗光文件描述符空间从而导致性能下降，最终拒绝服务。
</p>

<p>
对付这种问题，一般需要双方都进行连接心跳检测。比如：连接空闲一段时间后一方发一个心跳请求，另一端回个心跳响应，心跳请求发送方一段时间后还收不到响应则认为连接已断开，心跳请求接收方一段时间内没有收到心跳请求也认为连接已断开。
</p>

<p>
需要注意到的是node.js的tls服务器端握手超时处理不当可能会导致TCP死连接出现，有问题的代码示例如下：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">options</span> = {
<span style="background-color: #424242;"> </span>   key: <span style="color: #70c0b1;">"..."</span>,
<span style="background-color: #424242;"> </span>   cert: <span style="color: #70c0b1;">"..."</span>,
<span style="background-color: #424242;"> </span>   handshakeTimeout: 10*1000,
<span style="background-color: #424242;"> </span>   plain: <span style="color: #7aa6da;">true</span>,
<span style="background-color: #424242;"> </span>   ssl: <span style="color: #7aa6da;">true</span>
};

<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">tlsServer</span> = tls.createServer(options, app).listen(5433, 8192, <span style="color: #b9ca4a;">function</span>(){
<span style="background-color: #424242;"> </span>   logger.log(<span style="color: #70c0b1;">'tls server listening on port 5433'</span>);
});

tlsServer.on(<span style="color: #70c0b1;">'clientError'</span>, <span style="color: #b9ca4a;">function</span> (<span style="color: #e7c547;">exception</span>, <span style="color: #e7c547;">socket</span>) {
<span style="background-color: #424242;"> </span>   logger.warn(<span style="color: #70c0b1;">'tls server client('</span> + socket.remoteAddress + <span style="color: #70c0b1;">':'</span> + socket.remot<span style="text-decoration: underline;">ePort +</span><span style="color: #70c0b1; text-decoration: underline;">') error('</span><span style="text-decoration: underline;"> + exception + </span><span style="color: #70c0b1; text-decoration: underline;">')'</span><span style="text-decoration: underline;">);</span>
});
</pre>
</div>

<p>
上面的代码通过指定 <code>handshakeTimeout</code> 使用指定SSL握手超时时间，但是并未关闭底层的TCP连接，从而导致TCP连接泄露，在 <code>clientError</code> 事件处理函数中添加以下释放语句即可：
</p>

<div class="org-src-container">

<pre class="src src-js">socket.destroy();
</pre>
</div>

<p>
除了常见的断电、死机引起TCP死连接外，这里还有一个论坛帖子论坛其它原因：《<a href="http://serverfault.com/questions/504187/too-many-established-connections-left-open">Too many established connections left open</a>》。
</p>

<p>
另外还有 linux 内核的 tcp keepalive机制作为心跳解决方案：《<a href="http://machael.blog.51cto.com/829462/211989/">linux下使用TCP存活(keepalive)定时器</a>》。
</p>

<p>
谨记：除了主动通过连接发送数据外，其它情况下操作系统可能不会告诉你连接已经关闭了。
</p>

<p>
要彻底解决这个问题，除了要避免泄露（或忘记关闭）TCP连接外，要有心跳机制，还需要从代码层面进行防御性编程，如：对于读写操作设置超时时间，一旦超时主动关闭连接。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[理解node.js中的Error对象]]></title>
            <link>/article/740689e3-node.js-4e2d7684-error-5bf98c61.html</link>
            <guid>/article/740689e3-node.js-4e2d7684-error-5bf98c61.html</guid>
            <pubDate>Tue, 09 Dec 2014 05:38:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
Error对象在 <a href="http://nodejs.org">node.js</a> 程序中无处不在，但是关于它在 <a href="http://nodejs.org/docs/latest/api/all.html">node.js文档</a> （写这篇文章时node.js的最新版本为v0.10.33）中却找不到描述资料，只在以下部分提及：
</p>

<dl class="org-dl">
<dt> <a href="http://nodejs.org/docs/latest/api/all.html#all_util_iserror_object">util.isError(object)</a> </dt><dd>判断对象是否为Error对象.
</dd>

<dt> <a href="http://nodejs.org/docs/latest/api/all.html#all_additions_to_error_objects">Domain: Additions to Error objects</a> </dt><dd>在Error对象上附加额外的字段.
</dd>
</dl>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Error到底是何方神圣？</h2>
<div class="outline-text-2" id="text-1">
<p>
Error对象是在ECMAScript 5.1（于2011年7月发布）中 <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.11">定义</a> 的，是一个比较新的特性：
</p>

<blockquote>
<p>
Instances of Error objects are thrown as exceptions when runtime errors occur. The Error objects may also serve as base objects for user-defined exception classes.
</p>
</blockquote>

<p>
它只有两个属性：
</p>

<dl class="org-dl">
<dt> name </dt><dd>错误名称，默认为"Error"
</dd>

<dt> message </dt><dd>错误消息，默认为""
</dd>
</dl>

<p>
V8实现了一个扩展属性：
</p>

<dl class="org-dl">
<dt> stack </dt><dd>错误描述及调用堆栈 
</dd>
</dl>

<p>
它只有一个方法：
</p>

<dl class="org-dl">
<dt> toString </dt><dd>转成字符串形式，通常为 "name: message"
</dd>
</dl>

<p>
构造一个Error实例：
</p>

<p>
new Error(message) 或者 Error(message)，两者是一样的。
</p>

<p>
示例：显示错误消息
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err);
console.log(err.toString());
console.log(err.message);
</pre>
</div>

<p>
需要注意的是console.log(JSON.stringify(err))显示的是空对象{}.
</p>

<p>
示例：显示错误消息及调用堆栈
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err.stack);
</pre>
</div>

<p>
示例：显示错误名称
</p>

<div class="org-src-container">

<pre class="src src-js">console.log(err.name);
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">如何自定义Error类型？</h2>
<div class="outline-text-2" id="text-2">
<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">function</span> <span style="color: #e78c45;">MyError</span>(<span style="color: #e7c547;">message</span>) {
<span style="background-color: #424242;"> </span> <span style="color: #7aa6da;">this</span>.message = message || <span style="color: #70c0b1;">''</span>;
}

MyError.<span style="color: #7aa6da;">prototype</span> = <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">Error</span>();
MyError.<span style="color: #7aa6da;">prototype</span>.constructor = MyError;
MyError.<span style="color: #7aa6da;">prototype</span>.name = <span style="color: #70c0b1;">'MyError'</span>;
</pre>
</div>

<p>
Error实例类型判断
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">err</span> = <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">Error</span>(<span style="color: #70c0b1;">"this is error"</span>);
<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">myerr</span> = <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">MyError</span>(<span style="color: #70c0b1;">"this is my error"</span>);
err <span style="color: #b9ca4a;">instanceof</span> <span style="color: #7aa6da;">Error</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">true*/</span>
err <span style="color: #b9ca4a;">instanceof</span> <span style="color: #7aa6da;">MyError</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">false*/</span>
myerr <span style="color: #b9ca4a;">instanceof</span> <span style="color: #7aa6da;">MyError</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">true*/</span>
myerr <span style="color: #b9ca4a;">instanceof</span> <span style="color: #7aa6da;">Error</span> <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">true*/</span>
</pre>
</div>

<p>
stack输出有问题：自定义的错误描述没了
</p>

<div class="org-src-container">

<pre class="src src-js">err.stack <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">'Error: this is error\n    at repl:1:11 ...*/</span>
myerr.stack <span style="color: #969896; font-style: italic;">/*</span><span style="color: #969896; font-style: italic;">'MyError\n    at repl:1:21 ...*/</span>
</pre>
</div>

<p>
修复node.js下MyError的stack不正确的问题
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">function</span> <span style="color: #e78c45;">MyError</span>(<span style="color: #e7c547;">message</span>) {
<span style="background-color: #424242;"> </span> Error.captureStackTrace(<span style="color: #7aa6da;">this</span>, <span style="color: #7aa6da;">this</span>.constructor)
<span style="background-color: #424242;"> </span> <span style="color: #7aa6da;">this</span>.message = message || <span style="color: #70c0b1;">''</span>;
}

MyError.<span style="color: #7aa6da;">prototype</span> = <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">Error</span>();
MyError.<span style="color: #7aa6da;">prototype</span>.constructor = MyError;
MyError.<span style="color: #7aa6da;">prototype</span>.name = <span style="color: #70c0b1;">'MyError'</span>;
</pre>
</div>

<p>
<b>最终版：更node.js化一些</b>
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">function</span> <span style="color: #e78c45;">MyError</span>(<span style="color: #e7c547;">message</span>) {
<span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">if</span> (!(<span style="color: #7aa6da;">this</span> <span style="color: #b9ca4a;">instanceof</span> <span style="color: #7aa6da;">MyError</span>)) {
<span style="background-color: #424242;"> </span>   <span style="background-color: #424242;"> </span>   <span style="color: #b9ca4a;">return</span> <span style="color: #b9ca4a;">new</span> <span style="color: #7aa6da;">MyError</span>(message);
<span style="background-color: #424242;"> </span>   }
<span style="background-color: #424242;"> </span>   Error.captureStackTrace(<span style="color: #7aa6da;">this</span>, <span style="color: #7aa6da;">this</span>.constructor)
<span style="background-color: #424242;"> </span>   <span style="color: #7aa6da;">this</span>.message = message || <span style="color: #70c0b1;">''</span>;
}

util.inherits(MyError, Error)
MyError.<span style="color: #7aa6da;">prototype</span>.name = <span style="color: #70c0b1;">'MyError'</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">参考</h2>
<div class="outline-text-2" id="text-3">
<dl class="org-dl">
<dt> <a href="https://docs.nodejitsu.com/articles/errors/what-is-the-error-object">What is the error object?</a> </dt><dd>对Error对象的成员有所提及，但与当前的node.js版本不一致。
</dd>

<dt> <a href="https://cnodejs.org/topic/52090bc944e76d216af25f6f">Node.js下自定义错误类型</a> </dt><dd>教你如何自定义错误类型。
</dd>

<dt> <a href="http://stackoverflow.com/questions/10624873/what-properties-does-nodejs-expresss-error-object-exposes">What properties does nodejs express's Error object exposes?</a> </dt><dd>讨论Error对象相关属性
</dd>

<dt> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">MDN &gt; Web technology for developers &gt; JavaScript &gt; JavaScript reference &gt; Standard built-in objects &gt; Error</a> </dt><dd>Error对象参考文档
</dd>

<dt> <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.11">Error Objects</a> </dt><dd>Error对象标准文档
</dd>
</dl>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[编译安装node.js]]></title>
            <link>/article/7f168bd15b8988c5-node.js.html</link>
            <guid>/article/7f168bd15b8988c5-node.js.html</guid>
            <pubDate>Mon, 17 Feb 2014 08:23:00 GMT</pubDate>
            <content:encoded><![CDATA[<ul class="org-ul">
<li>下载

<p>
node.js是一个新兴的开发平台，版本更新非常活跃，因此应该尽量下载安装最新的版本。
</p>

<p>
到 <a href="http://nodejs.org/">http://nodejs.org/</a> 下载最新的版本。
</p>
</li>

<li>安装

<p>
解压后参照 README.md 进行安装：
</p>

<div class="org-src-container">

<pre class="src src-sh">./configure
make
make install
</pre>
</div>
</li>

<li>安装后

<p>
默认安装到/usr/local。
</p>

<dl class="org-dl">
<dt> /usr/local/bin/node </dt><dd>node主程序
</dd>
<dt> /usr/local/bin/npm </dt><dd>node模块管理程序
</dd>
<dt> /usr/local/lib/node_modules </dt><dd>node全局模块目录
</dd>
</dl>
<p>
像一些需要全局安装的模块也会把文件安装在/usr/local目录下。
</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[express.js中如何在第一次请求的响应中取得connect.sid]]></title>
            <link>/article/express.js-4e2d59824f5557287b2c4e006b218bf76c42768454cd5e944e2d53d65f97-connect.sid.html</link>
            <guid>/article/express.js-4e2d59824f5557287b2c4e006b218bf76c42768454cd5e944e2d53d65f97-connect.sid.html</guid>
            <pubDate>Fri, 14 Feb 2014 15:34:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
在web页面通过iframe跨域登录访问服务的情况下，是不方便取cookie中的sessionid的，于是想到将sessionid直接放到响应体中，
这就需要在node.js中直接获取connect.sid这个cookie值，一开始想当然地以为系统（使用的是passport.js）会在登录认证通过后
执行res.cookie('connect.sid', &#x2026;)进行设置，就想直接从res的Set-Cookie头解析出设置的值，结果发现这个cookie压根不存在，
甚至在库代码中搜索cookie都不管用，着实急得人直抓头。最后dump出res后确在req中见到了connect.sid值的影子：req.sessionID，
然后在 <a href="http://stackoverflow.com/questions/13693101/express-sessionid-differs-from-sessionid-in-cookie">《Express SessionID differs from SessionID in Cookie》</a> 中找到了从req.sessionID计算出connect.sid的方法：
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">signature</span> = require(<span style="color: #70c0b1;">'express/node_modules/cookie-signature'</span>);
<span style="color: #b9ca4a;">var</span> <span style="color: #e7c547;">connectSid</span> = <span style="color: #70c0b1;">'s:'</span> + signature.sign(req.sessionID, sessionOptions.secret);
</pre>
</div>

<p>
其实，connect.sid这个cookie是在请求到来后在req上设置的（不存在则设置），不管有没有登录都会设置。</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[node.js下访问mysql注意事项]]></title>
            <link>/article/node.js-4e0b8bbf95ee-mysql-6ce8610f4e8b9879.html</link>
            <guid>/article/node.js-4e0b8bbf95ee-mysql-6ce8610f4e8b9879.html</guid>
            <pubDate>Fri, 11 Oct 2013 02:45:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
本文仅针对 <a href="https://github.com/felixge/node-mysql">node-mysql</a> 模块。
</p>

<ul class="org-ul">
<li>Connection 对象为一个到mysql的连接，在其上的query是串行进行的。

<p>
由于mysql协议类似http是串行的，在一个mysql连接上的多个query必须依次进行。
</p>

<p>
<a href="https://github.com/felixge/node-mysql">node-mysql</a> 的 Connection对象上同时发起的多个query会队列化，
</p>

<p>
处理完一个query再进行下一query的处理，传递给回调函数的query结果不会错乱。
</p>

<p>
在有一定访问量的服务中应该总是使用 <code>连接池</code> 。
</p>
</li>
</ul>


<ul class="org-ul">
<li>处理Connection对象的重连。

<p>
mysql连接空闲一段时间后（默认8小时）会自动关闭，
</p>

<p>
可以在Connection对象的 <code>error</code> 事件中检测后连接断开时进行重连。
</p>

<p>
使用 <code>连接池</code> 不会有问题，连接断开后会默认从连接池中剔除。</p>
</li>
</ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《理解Node.js》培训课件]]></title>
            <link>/article/300a740689e3-node.js-300b57f98bad8bfe4ef6.html</link>
            <guid>/article/300a740689e3-node.js-300b57f98bad8bfe4ef6.html</guid>
            <pubDate>Thu, 04 Jul 2013 10:31:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
本课件介绍Node.js的特点及其初步使用。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">开发计划 <code>[1/3]</code></h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li><code>[X]</code> 编写大纲
</li>
<li><code>[&#xa0;]</code> 编写内容
</li>
<li><code>[&#xa0;]</code> 制作Microsoft PowerPoint格式文档
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">在线演示</h2>
<div class="outline-text-2" id="text-2">
<p>
<a href="http://blog.kankanan.com/slides/%E7%90%86%E8%A7%A3Node.js.html">《理解Node.js》</a></p>
</div>
</div>
]]></content:encoded>
        </item>
    </channel>
</rss>