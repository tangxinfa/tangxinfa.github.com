<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>envoy - 看看俺 – KanKanAn.com</title>
        <link>http://blog.kankanan.com/tag/envoy.xml</link>
        <description>记我所思，忆我所为。</description>
        <lastBuildDate>Fri, 01 Dec 2017 10:05:32 GMT</lastBuildDate>
        <docs>http://blogs.law.harvard.edu/tech/rss</docs>
        <generator>Feed for Node.js</generator>
        <image>
            <title>envoy - 看看俺 – KanKanAn.com</title>
            <url>http://blog.kankanan.com/static/favicon.ico</url>
            <link>http://blog.kankanan.com/tag/envoy.xml</link>
        </image>
        <copyright>版权所有 © 2011-2015 看看俺 – KanKanAn.com</copyright>
        <category>技术</category>
        <item>
            <title><![CDATA[使用 Envoy 做为 socket.io 的前端代理]]></title>
            <link>/article/4f7f7528-envoy-505a4e3a-socket.io-7684524d7aef4ee37406.html</link>
            <guid>/article/4f7f7528-envoy-505a4e3a-socket.io-7684524d7aef4ee37406.html</guid>
            <pubDate>Mon, 20 Nov 2017 06:39:00 GMT</pubDate>
            <content:encoded><![CDATA[
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">示例 socket.io 项目</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>编译

<div class="org-src-container">

<pre class="src src-sh">go get github.com/tangxinfa/envoy-socket.io-example
<span style="color: #b294bb;">cd</span> $<span style="color: #f0c674;">GOPATH</span>/src/github.com/tangxinfa/envoy-socket.io-example
glide install
go build
</pre>
</div>
</li>

<li>运行

<div class="org-src-container">

<pre class="src src-sh">./envoy-socket.io-example -addr 127.0.0.1:8001 -logtostderr
</pre>
</div>
</li>

<li>用浏览器打开 <code>http://localhost:8001</code>

<p>
正常情况下，会收到 <code>welcome</code> 消息，表示 <code>socket.io</code> 连接成功，可以在下方的编辑框输入内容，服务器会 echo 回来。
这是客户端直接 socket.io 服务，接下来将展示使用 Envoy 做为前端代理来访问后端的 socket.io 服务。
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">修复 Envoy 的 Websocket 相关 Bug</h2>
<div class="outline-text-2" id="text-2">
<p>
之前的 Envoy 版本为
</p>
<pre class="example">
commit 3e43c2225c8882918b36b4b7c7bb55c6af2db929
Author: Greg Greenway &lt;ggreenway@users.noreply.github.com&gt;
Date:   Wed Nov 15 14:48:38 2017 -0800

Fix v2 TcpProxy config (#2065)

Signed-off-by: Greg Greenway &lt;ggreenway@apple.com&gt;
</pre>

<p>
存在两个问题导致 Websocket 不可用：
</p>

<ul class="org-ul">
<li>Connection 请求头包含多个值时未能正确处理，导致未正确判断出 Websocket 请求

<p>
Firefox 发起的 Websocket 请求 Connection 头的值为： <code>keep-alive, Upgrade</code> 。
</p>
</li>
</ul>


<ul class="org-ul">
<li>Envoy 向 Upstream 发起的 Websocket 请求多了一个 <code>transfer-encoding: chunked</code> 请求头

<p>
由于请求体是空的，所以是一个无效的 HTTP 请求。
</p>
</li>
</ul>


<p>
我提交了 Pull Request <a href="https://github.com/envoyproxy/envoy/pull/2070">#2070</a> ，已合到 <code>master</code> 分支，该问题已修复。
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">将 Envoy 做为 socket.io 服务前端代理</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>启动 Envoy

<p>
使用是的修复 BUG 后的 Envoy。
</p>

<div class="org-src-container">

<pre class="src src-sh">~/Opensource/envoy/bazel-bin/source/exe/envoy-static --log-level trace --config-<span style="color: #de935f; background-color: #373b41;">path ./envoy.json</span>
</pre>
</div>
</li>
</ul>


<ul class="org-ul">
<li>用浏览器打开 <code>http://localhost:9001</code>

<p>
正常情况下，会收到 <code>welcome</code> 消息，表示 socket.io 连接成功，可以在下方的编辑框输入内容，服务器会 echo 回来。
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">将 Envoy 做为 socket.io 服务集群前端代理</h2>
<div class="outline-text-2" id="text-4">
<p>
在后台服务为集群的情况下，Envoy 会通过负载均衡将请求调度到所有服务结点，
对于无状态服务，不管 Envoy 使用什么样的负载均衡策略都可以正常工作，
但是对于有状态的服务，则要求将一个用户的请求总是调度到同一个服务结点。
</p>

<blockquote>
<p>
Socket.IO never assumes that WebSocket will just work, because in practice there’s a good chance that it won’t. Instead, it establishes a connection with XHR or JSONP right away, and then attempts to upgrade the connection to WebSocket. Compared to the fallback method which relies on timeouts, this means that none of your users will have a degraded experience.
</p>
</blockquote>
<p>
引用自 <a href="https://mashhurs.wordpress.com/2016/09/30/polling-vs-websocket-transport/">Socket.IO Polling vs. WebSocket Transport – on Balancing Methods</a>。
</p>

<p>
socket.io 的 <code>transports</code> 选项默认值为 <code>['polling', 'websocket']</code> ，
也就是说首先发一个 HTTP 轮询请求，根据响应决定是否升级到使用 <code>websocket</code> ，
这样在 Websocket 可用的情况下，会有两次 HTTP 交互，需确保两次 HTTP 交互
调度到同一个服务结点，socket.io 连接才能建立成功。
</p>

<p>
Envoy 本身支持多种负载均衡策略，适合这里的场景是 <code>Ring hash</code> 。
</p>

<blockquote>
<p>
Ring hash
</p>

<p>
The ring/modulo hash load balancer implements consistent hashing to upstream hosts. The algorithm is based on mapping all hosts onto a circle such that the addition or removal of a host from the host set changes only affect 1/N requests. This technique is also commonly known as “ketama” hashing. The consistent hashing load balancer is only effective when protocol routing is used that specifies a value to hash on. Currently the only implemented mechanism is to hash via HTTP header values in the HTTP router filter. 
</p>
</blockquote>

<p>
遗憾的是 Envoy 的 Websocket 实现过于简陋，当检测到 <code>Websocket</code> 升级请求时，
它以 <code>TcpProxy</code> 的方式连接上游服务器，检测到非 <code>Websocket</code> 升级请求时，
会正常地做为 HTTP 请求进行处理。由于 <code>TcpProxy</code> 只支持随机 Hash 算法选择上游服务结点，
会导致默认情况下 socket.io 连接无法建立。
</p>

<p>
通过指定 socket.io 的 <code>transports</code> 选项值为 <code>['websocket', 'polling']</code> ，
也就是首先尝试建立 <code>websocket</code> 连接，失败时再降级为 <code>polling</code> ，能够解决这个问题。
</p>

<p>
Envoy 的 <code>Ring hash</code> 是根据配置的请求头来计算 Hash 值的，刚刚有一个按特定 Cookie 计算 Hash 值的
Pull Request <a href="https://github.com/envoyproxy/envoy/pull/1766">Implement cookie hashing for v2 API #1766</a> 已经合并到 master 分支，官方文档方面还没有更新，
本文暂不采用。
</p>

<p>
一般 Web 前端都是通过自定义请求头或者 Cookie 中的特定字段来标识一个用户，由于 Cookie
可能会在交互过程中发生变化，因此不适合用于计算 Hash 值，而 Websocket 升级请求又不支持自定义请求头，
因此这两种常用的方式失效了。
</p>

<p>
另一个合理的选择是通过 <code>Referer</code> 请求头来计算 Hash，这是客户端网页的地址，不会在交互过程中变化，
只要想办法将用户的标识（如 ID）附在 URL 上，如：<a href="http://www.example.com/chat?uid=1234">http://www.example.com/chat?uid=1234</a> ，
就可以保证用户请求能够均衡地分布到所有服务结点上，同一用户的请求也会调度到同一个服务结点。
</p>

<p>
如下所示。
</p>

<ul class="org-ul">
<li>启动服务集群

<div class="org-src-container">

<pre class="src src-sh">./envoy-socket.io-example -127.0.0.1:8002 -logtostderr &amp;
./envoy-socket.io-example -127.0.0.1:8003 -logtostderr &amp;
./envoy-socket.io-example -127.0.0.1:8004 -logtostderr &amp;
</pre>
</div>
</li>

<li>启动 Envoy

<p>
使用是的修复 BUG 后的 Envoy。
</p>

<div class="org-src-container">

<pre class="src src-sh">~/Opensource/envoy/bazel-bin/source/exe/envoy-static --log-level trace --config-<span style="color: #de935f; background-color: #373b41;">path ./envoy2.json</span>
</pre>
</div>
</li>
</ul>


<ul class="org-ul">
<li>用浏览器打开多个 <code>http://localhost:9002/index2.html</code> 页面

<p>
正常情况下，每个页面都会收到 <code>welcome</code> 消息，表示 socket.io 连接成功，可以在下方的编辑框输入内容，服务器会 echo 回来。
</p>
</li>
</ul>
</div>
</div>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Envoy 的 json_transcoder_filter 介绍]]></title>
            <link>/article/envoy-7684-json_transcoder_filter-4ecb7ecd.html</link>
            <guid>/article/envoy-7684-json_transcoder_filter-4ecb7ecd.html</guid>
            <pubDate>Thu, 12 Oct 2017 11:56:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>
json_transcoder_filter 实现 HTTP/1.1+JSON 与 HTTP/2+GRPC 的互转。
</p>

<p>
使用第三方库 <a href="https://github.com/grpc-ecosystem/grpc-httpjson-transcoding">grpc-httpjson-transcoding</a> 完成 json 与 grpc 的协议转换，
转换规则由 <a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto">http.proto</a> 定义。
</p>

<p>
<a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto">http.proto</a> 通过注解（Annotations）为 GRPC 接口添加 RESTful HTTP 接口映射。
</p>

<p>
<code>json_transcoder_filter</code> 对 stream 有一定支持，由于它是基于 HTTP/1.1，本质上是请求-响应模型，
只支持 GRPC 的 <code>Server streaming</code> 和 <code>Client streaming</code> ，不支持 <code>Bidirectional streaming</code> ，
它将 GRPC 消息流映射为消息数组（Json array）。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">示例项目</h2>
<div class="outline-text-2" id="text-1">
<p>
Envoy 带了一个 <a href="https://github.com/envoyproxy/envoy/tree/master/examples/grpc-bridge">grpc-bridge 示例项目</a>，依照它做了一个 grpc_json_transcoder 示例项目：
</p>

<ul class="org-ul">
<li><a href="https://github.com/tangxinfa/grpc_json_transcoder_example">tangxinfa/grpc_json_transcoder_example: Envoy grpc_json_transcoder filter example</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">参考</h2>
<div class="outline-text-2" id="text-2">
<ul class="org-ul">
<li><a href="https://cloud.google.com/endpoints/docs/grpc/transcoding">Transcoding HTTP/JSON to gRPC  |  Cloud Endpoints with gRPC  |  Google Cloud Platform</a>
</li>
</ul>
</div>
</div>
]]></content:encoded>
        </item>
    </channel>
</rss>