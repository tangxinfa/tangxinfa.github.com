<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<title>当php遇上redis</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="当php遇上redis"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="&lt;2012-12-08 六&gt;"/>
<meta name="author" content="tangxinfa"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<link rel='stylesheet' type='text/css' href='css/style.css' />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">
<div class='nav-bar'><ul><li><a href='index.html' class='nav-bar-blog' style='color: #FFFFFF;'>博客</a></li></ul></div>
</div>

<div id="content">
<h1 class="title">当php遇上redis</h1>


<div class="tag-bar">
</div>

<p>
在最近的项目中，我们需要在php中访问redis，我们选择了使用<a href="https://github.com/nicolasff/phpredis">phpredis</a>库，下面是遇到的一些问题。
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">redis持久连接不靠谱。</h2>
<div class="outline-text-2" id="text-1">


<p>
  可以说这是php的通病了，不管是mysql、memcache还是redis，指望由php本身（包含php扩展）来实现持久连接都是行不通的。
</p>
<dl>
<dt>为什么这么说呢？</dt><dd>
<p>
    首先，所谓的持久连接的实现不外乎在进程（php-fpm）内建一个连接池，当php需要连接时，先以ip+port等信息为key在池中查找，找到则直接返回已有连接没有则新建连接。而当一个请求执行结束时，不关闭连接，而是把连接归还到池中。
</p>
<p>    
    这样当php需要用到多个redis实例时（分库），因为一个php-fpm进程会持有每个redis实例的一个连接，所以需要“php-fpm进程数“*“redis实例数"个redis连接，而对于每个redis服务器则有“php-fpm进程数“个客户端连接。
</p>
<p>
    举个例子：一个web应用开了1000个php-fpm进程，有10个redis实例，那么保持的redis连接数就为1000*10也就是10000，每个redis实例有1000个客户端连接。如果前端或redis再扩容所需要的连接就会以乘积方式增加。一个redis实例有php-fpm进程数个连接的情况下表现如何呢，这就要好好测一测了，反正是每连接一线程的mysql是直接堵死了。
</p></dd>
</dl>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">RedisArray不靠谱。</h2>
<div class="outline-text-2" id="text-2">

<p>  RedisArray实现了一致性hash分布式，但是它在初始化的时候就会连接上每个实例，这在web应用中简直是胡闹，它对一致性hash实现得比较完善，结点失效、动态添加结点时重新hash都有处理，在万不得已进行水平扩容时，可能会用得上。
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">需要自已关闭redis连接。</h2>
<div class="outline-text-2" id="text-3">

<p>  Redis的析构函数没有关闭redis连接，这会导致redis网络负载过高，要确保脚本结束时关闭连接，最好是能够封装一下Redis类再使用。
</p>
<dl>
<dt>示例封装</dt><dd>
</dd>
</dl>




<pre class="example">/// 分布式Redis.
class RedisShard {
    public function __construct($shards) {
        $this-&gt;shards = array();
        foreach($shards as $shard){
            $this-&gt;shards[] = explode(':', $shard); //格式：host:port:db
        }
    }

    /// 析构函数.
    /// 脚本结束时，phpredis不会自动关闭redis连接，这里添加自动关闭连接支持.
    /// 可以通过手动unset本类对象快速释放资源.
    public function __destruct() {
        if(isset($this-&gt;shard)){
            $this-&gt;shard['redis']-&gt;close();
        }
    }

    /// 转发方法调用到真正的redis对象.
    public function __call($name, $arguments) {
        $result = call_user_func_array(array($this-&gt;redis($arguments[0]), $name), $arguments);
        if($result === false and in_array($name, array('set', 'setex', 'incr'))) {
            trigger_error("redis error: $name " . implode(' ', $arguments), E_USER_NOTICE);
        }
        return $result;
    }

    /// 获取key对应的redis对象.
    private function redis($key){
        //TODO: crc32在32位系统下会返回负数，因我们是部署在64位系统上，暂时忽略.
        assert(PHP_INT_SIZE === 8);
        $index = crc32($key) % count($this-&gt;shards);
        $shard = $this-&gt;shards[$index];
        if(isset($this-&gt;shard)){
            //尝试重用已有连接.
            if($this-&gt;shard[0] == $shard[0] and $this-&gt;shard[1] == $shard[1]){
                if($this-&gt;shard[2] != $shard[2]){
                    if(! $this-&gt;shard['redis']-&gt;select($shard[2])){
                        return false;
                    }
                    $this-&gt;shard[2] = $shard[2];
                    return $this-&gt;shard['redis'];
                }
            }
            $this-&gt;shard['redis']-&gt;close();
            unset($this-&gt;shard);
        }
        //新建连接.
        $shard['redis'] = new Redis();
        if(! $shard['redis']-&gt;connect($shard[0], $shard[1])){
            trigger_error('redis error: connect ' . $shard[0] . ':' . $shard[1], E_USER_NOTICE);
            return false;
        }
        $db = intval($shard[2]);
        if($db != 0 and !$shard['redis']-&gt;select($db)){
            trigger_error('redis error: select ' . $shard[0] . ':' . $shard[1] . ':' .$shard[2], E_USER_NOTICE);
            $shard['redis']-&gt;close();
            return false;
        }
        $this-&gt;shard = $shard;
        return $this-&gt;shard['redis'];
    }
}
</pre>


        <div class="comment_header">评论</div>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'kankananblog';
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
        <div style="display:none;">
        <script type="text/javascript">
            var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Faa06d8a31344740ac23cbe6cf3d9f23e' type='text/javascript'%3E%3C/script%3E"));
        </script>
        </div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: &lt;2012-12-08 六&gt;</p>
<p class="author">Author: tangxinfa</p>
<p class="creator">Org version 7.8.02 with Emacs version 23</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
