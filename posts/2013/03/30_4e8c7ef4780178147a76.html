<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8"/>
    <title>二维码研究 | 看看俺 - KanKanAn.com</title>
    <link rel="stylesheet" type="text/less" href="../../../style/less/o-blog.less"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="generator" content="o-blog version 1.2-148-g6da8733"/>
    <script src="../../../style/js/less-1.3.0.min.js" type="text/javascript"></script>
    <script src="../../../style/js/jquery-1.7.1.min.js" type="text/javascript"></script>
    <script src="../../../style/bootstrap/js/bootstrap-modal.js" type="text/javascript"></script>
    <script src="../../../style/bootstrap/js/bootstrap-transition.js" type="text/javascript"></script>
    <script src="../../../style/bootstrap/js/bootstrap-dropdown.js" type="text/javascript"></script>
    <script src="../../../style/bootstrap/js/bootstrap-collapse.js" type="text/javascript"></script>
    <script src="../../../style/js/prettify.js" type="text/javascript"></script>
    <script src="../../../style/js/o-blog.linenumber.js" type="text/javascript"></script>
    <script src="../../../style/js/o-blog-fix.js" type="text/javascript"></script>
    
    
  </head>
  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
	<div class="container">
	  <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
	  <a class="brand" href="../../../index.html">看看俺 - KanKanAn.com</a>
	  <div class="nav-collapse collapse">
	    <ul>
<li><a href="../../../archives.html"><i>icon-list icon-white</i> 归档</a>

</li>
<li><a href="../../../tags.html"><i>icon-tags icon-white</i> 标签</a>

</li>
<li><a href="../../../index.xml"><i>icon-rss icon-white</i> 订阅</a>
</li>
</ul>



	  </div>
	</div>
      </div>
    </div>
    <div id="page" class="container">

  <div class="article">
  <header class="article-header">

    <div class="page-header">
      <div class="row">
	<div class="date span1">
	  <div class=" date-d">30</div>
	  <div class=" date-m"><a href="../../../posts/2013/03/index.html">3月</a></div>
	  <div class=" date-y"><a href="../../../posts/2013/index.html">2013</a>
	  </div>
	</div>
	<div class="span1">
	  <div class="qr-code">
  <img style="min-width:90px; min-height:90px; max-width:90px; max-height:90px;" src="http://chart.apis.google.com/chart?chs=90x90&cht=qr&chld=|0&chl=http%3A%2F%2Fblog.kankanan.com%2Fposts%2F2013%2F03%2F30_4e8c7ef4780178147a76.html"
       alt="qr-code" />
</div>

	</div>
	<h1 class="offset2">二维码研究</h1>
      </div>
      <nav>
	<ul class="pager">
	  <li class="previous"><a href="../../../posts/2013/03/27_archlinux4e0b5b8988c5cups625353707cfb7edf.html"><i class="icon-chevron-left"></i>&nbsp;Archlinux下安装cups打印系统</a></li><li class="next" style="text-align: right;"><a href="../../../posts/2013/03/30_5728emacs4e2d59824f554ee5root674396504f7f7528gdb8c038bd57a0b5e8f.html">在emacs中如何以root权限使用gdb调试程序&nbsp;<i class="icon-chevron-right"></i></a></li>
	</ul>
      </nav>
    </div>

  </header>
  <div class="article-content">
    <div id="outline-container-1" class="outline-3">
<h3 id="sec-1">介绍</h3>
<div class="outline-text-3" id="text-1">

<dl>
<dt><a href="http://www.itsc.org.sg/pdf/synthesis08/Three_QR_Code.pdf">Three_QR_Code.pdf</a></dt><dd>
<p>
     RFC式的文档
</p>
</dd>
<dt><a href="http://suflow.iteye.com/blog/1100678">二维码 编码原理简介</a></dt><dd>
<p>
     通俗易懂的编码细节介绍
</p>
</dd>
<dt><a href="http://zh.wikipedia.org/wiki/QR碼">QR碼 - 维基百科，自由的百科全书</a></dt><dd>

</dd>
<dt><a href="http://www.qrstuff.com/blog/2011/11/23/qr-code-minimum-size">QR Code Minimum Size</a> 与 <a href="http://www.qrstuff.com/blog/2011/01/18/what-size-should-a-qr-code-be">What Size Should A Printed QR Code Be?</a></dt><dd>
<p>
     关于可识别性的一些结论，该网站上有大量二维码研究相关的文章
</p></dd>
</dl>


</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2">二维码开发库</h3>
<div class="outline-text-3" id="text-2">

<dl>
<dt><a href="https://github.com/fukuchi/libqrencode">libqrencode</a></dt><dd>
<p>
     基础的c语言二维码编码库，很多语言基于它开发扩展，不包含生成png图的功能，如需生成png可参考<a href="https://github.com/bitly/simplehttp/blob/master/qrencode/qrencode.c">这里</a>
</p></dd>
<dt><a href="https://github.com/jeromeetienne/jquery-qrcode">jquery-qrcode</a></dt><dd>
<p>
     使用javascript直接在客户端生成二维码，中文支持参见<a href="http://suflow.iteye.com/blog/1687396">JS生成二维码，支持中文字符</a>
</p></dd>
<dt><a href="http://people.freebsd.org/~vanilla/qrencode-0.3.tar.bz2">php's qrencode extension</a></dt><dd>
<p>
     使用nginx的扩展性能会更好一点，参考后面<a href="#sec-3">nginx的相关扩展</a>.
</p></dd>
<dt><a href="http://trac.koka-in.org/libdecodeqr">libdecodeqr</a></dt><dd>
<p>
     二维码解码库
</p></dd>
</dl>


</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3">nginx的相关扩展</h3>
<div class="outline-text-3" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-4">
<h4 id="sec-3-1">基本的二维码</h4>
<div class="outline-text-4" id="text-3-1">

<p>    <a href="https://github.com/dcshi/ngx_http_qrcode_module">ngx_http_qrcode_module</a>
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-4">
<h4 id="sec-3-2">二维码个性化水印</h4>
<div class="outline-text-4" id="text-3-2">

<p>   nginx_http_image_filter加上<a href="http://forum.nginx.org/read.php?21,235958">水印补丁</a>即可。
</p>
<p>
   下面的是经过修改后的 <code>nginx image filter</code> 模块代码，加入居中的水印效果:
</p>


<div class="o-blog-source"><a class="btn btn-info" data-toggle="modal" data-target="#ngx5fhttp5fimage5ffilter5fmodule2ec" ><i class="icon-file icon-white"></i>&nbsp;ngx_http_image_filter_module.c</a></div><div class="modal fade hide" id="ngx5fhttp5fimage5ffilter5fmodule2ec"><div class="modal-header"><a class="close" data-dismiss="modal">×</a><h3>ngx_http_image_filter_module.c</h3></div><div class="modal-body"><pre>

/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */


#include &lt;ngx_config.h&gt;
#include &lt;ngx_core.h&gt;
#include &lt;ngx_http.h&gt;

#include &lt;gd.h&gt;


#define NGX_HTTP_IMAGE_OFF       0
#define NGX_HTTP_IMAGE_TEST      1
#define NGX_HTTP_IMAGE_SIZE      2
#define NGX_HTTP_IMAGE_RESIZE    3
#define NGX_HTTP_IMAGE_CROP      4
#define NGX_HTTP_IMAGE_ROTATE    5
#define NGX_HTTP_IMAGE_WATERMARK 6


#define NGX_HTTP_IMAGE_START     0
#define NGX_HTTP_IMAGE_READ      1
#define NGX_HTTP_IMAGE_PROCESS   2
#define NGX_HTTP_IMAGE_PASS      3
#define NGX_HTTP_IMAGE_DONE      4


#define NGX_HTTP_IMAGE_NONE      0
#define NGX_HTTP_IMAGE_JPEG      1
#define NGX_HTTP_IMAGE_GIF       2
#define NGX_HTTP_IMAGE_PNG       3


#define NGX_HTTP_IMAGE_BUFFERED  0x08


typedef struct {
    ngx_uint_t                   filter;
    ngx_uint_t                   width;
    ngx_uint_t                   height;
    ngx_uint_t                   angle;
    ngx_uint_t                   jpeg_quality;
    ngx_uint_t                   sharpen;

    ngx_flag_t                   transparency;
    ngx_str_t                    watermark;
    ngx_uint_t                   watermark_transparency;
    
    ngx_http_complex_value_t    *wcv;
    ngx_http_complex_value_t    *hcv;
    ngx_http_complex_value_t    *acv;
    ngx_http_complex_value_t    *jqcv;
    ngx_http_complex_value_t    *shcv;

    size_t                       buffer_size;
} ngx_http_image_filter_conf_t;


typedef struct {
    u_char                      *image;
    u_char                      *last;

    size_t                       length;

    ngx_uint_t                   width;
    ngx_uint_t                   height;
    ngx_uint_t                   max_width;
    ngx_uint_t                   max_height;
    ngx_uint_t                   angle;

    ngx_uint_t                   phase;
    ngx_uint_t                   type;
    ngx_uint_t                   force;
} ngx_http_image_filter_ctx_t;


static ngx_int_t ngx_http_image_send(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx, ngx_chain_t *in);
static ngx_uint_t ngx_http_image_test(ngx_http_request_t *r, ngx_chain_t *in);
static ngx_int_t ngx_http_image_read(ngx_http_request_t *r, ngx_chain_t *in);
static ngx_buf_t *ngx_http_image_process(ngx_http_request_t *r);
static ngx_buf_t *ngx_http_image_json(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);
static ngx_buf_t *ngx_http_image_asis(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);
static void ngx_http_image_length(ngx_http_request_t *r, ngx_buf_t *b);
static ngx_int_t ngx_http_image_size(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);

static ngx_buf_t *ngx_http_image_resize(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);
static gdImagePtr ngx_http_image_source(ngx_http_request_t *r,
    ngx_http_image_filter_ctx_t *ctx);
static gdImagePtr ngx_http_image_new(ngx_http_request_t *r, int w, int h,
    int colors);
static u_char *ngx_http_image_out(ngx_http_request_t *r, ngx_uint_t type,
    gdImagePtr img, int *size);
static void ngx_http_image_cleanup(void *data);
static ngx_uint_t ngx_http_image_filter_get_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *cv, ngx_uint_t v);
static ngx_uint_t ngx_http_image_filter_value(ngx_str_t *value);


static void *ngx_http_image_filter_create_conf(ngx_conf_t *cf);
static char *ngx_http_image_filter_merge_conf(ngx_conf_t *cf, void *parent,
    void *child);
static char *ngx_http_image_filter(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);
static char *ngx_http_image_filter_jpeg_quality(ngx_conf_t *cf,
    ngx_command_t *cmd, void *conf);
static char *ngx_http_image_filter_sharpen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf);
static ngx_int_t ngx_http_image_filter_init(ngx_conf_t *cf);


static ngx_command_t  ngx_http_image_filter_commands[] = {

    { ngx_string(<span style="color: #2aa198;">"image_filter"</span>),
      NGX_HTTP_LOC_CONF|NGX_CONF_TAKE123,
      ngx_http_image_filter,
      NGX_HTTP_LOC_CONF_OFFSET,
      0,
      NULL },

    { ngx_string(<span style="color: #2aa198;">"image_filter_jpeg_quality"</span>),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_http_image_filter_jpeg_quality,
      NGX_HTTP_LOC_CONF_OFFSET,
      0,
      NULL },

    { ngx_string(<span style="color: #2aa198;">"image_filter_sharpen"</span>),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_http_image_filter_sharpen,
      NGX_HTTP_LOC_CONF_OFFSET,
      0,
      NULL },

    { ngx_string(<span style="color: #2aa198;">"image_filter_transparency"</span>),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_FLAG,
      ngx_conf_set_flag_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_image_filter_conf_t, transparency),
      NULL },

    { ngx_string(<span style="color: #2aa198;">"image_filter_buffer"</span>),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_size_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_image_filter_conf_t, buffer_size),
      NULL },

    { ngx_string(<span style="color: #2aa198;">"image_filter_watermark"</span>),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_str_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_image_filter_conf_t, watermark),
      NULL },

    { ngx_string(<span style="color: #2aa198;">"image_filter_watermark_transparency"</span>),
      NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE1,
      ngx_conf_set_num_slot,
      NGX_HTTP_LOC_CONF_OFFSET,
      offsetof(ngx_http_image_filter_conf_t, watermark_transparency),
      NULL },
    
      ngx_null_command
};


static ngx_http_module_t  ngx_http_image_filter_module_ctx = {
    NULL,                                  /* preconfiguration */
    ngx_http_image_filter_init,            /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    ngx_http_image_filter_create_conf,     /* create location configuration */
    ngx_http_image_filter_merge_conf       /* merge location configuration */
};


ngx_module_t  ngx_http_image_filter_module = {
    NGX_MODULE_V1,
    &amp;ngx_http_image_filter_module_ctx,     /* module context */
    ngx_http_image_filter_commands,        /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};


static ngx_http_output_header_filter_pt  ngx_http_next_header_filter;
static ngx_http_output_body_filter_pt    ngx_http_next_body_filter;


static ngx_str_t  ngx_http_image_types[] = {
    ngx_string(<span style="color: #2aa198;">"image/jpeg"</span>),
    ngx_string(<span style="color: #2aa198;">"image/gif"</span>),
    ngx_string(<span style="color: #2aa198;">"image/png"</span>)
};


static ngx_int_t
ngx_http_image_header_filter(ngx_http_request_t *r)
{
    off_t                          len;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    if (r-&gt;headers_out.status == NGX_HTTP_NOT_MODIFIED) {
        return ngx_http_next_header_filter(r);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx) {
        ngx_http_set_ctx(r, NULL, ngx_http_image_filter_module);
        return ngx_http_next_header_filter(r);
    }

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (conf-&gt;filter == NGX_HTTP_IMAGE_OFF) {
        return ngx_http_next_header_filter(r);
    }

    if (r-&gt;headers_out.content_type.len
            &gt;= sizeof(<span style="color: #2aa198;">"multipart/x-mixed-replace"</span>) - 1
        &amp;&amp; ngx_strncasecmp(r-&gt;headers_out.content_type.data,
                           (u_char *) <span style="color: #2aa198;">"multipart/x-mixed-replace"</span>,
                           sizeof(<span style="color: #2aa198;">"multipart/x-mixed-replace"</span>) - 1)
           == 0)
    {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                      <span style="color: #2aa198;">"image filter: multipart/x-mixed-replace response"</span>);

        return NGX_ERROR;
    }

    ctx = ngx_pcalloc(r-&gt;pool, sizeof(ngx_http_image_filter_ctx_t));
    if (ctx == NULL) {
        return NGX_ERROR;
    }

    ngx_http_set_ctx(r, ctx, ngx_http_image_filter_module);

    len = r-&gt;headers_out.content_length_n;

    if (len != -1 &amp;&amp; len &gt; (off_t) conf-&gt;buffer_size) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                      <span style="color: #2aa198;">"image filter: too big response: %O"</span>, len);

        return NGX_HTTP_UNSUPPORTED_MEDIA_TYPE;
    }

    if (len == -1) {
        ctx-&gt;length = conf-&gt;buffer_size;

    } else {
        ctx-&gt;length = (size_t) len;
    }

    if (r-&gt;headers_out.refresh) {
        r-&gt;headers_out.refresh-&gt;hash = 0;
    }

    r-&gt;main_filter_need_in_memory = 1;
    r-&gt;allow_ranges = 0;

    return NGX_OK;
}


static ngx_int_t
ngx_http_image_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
{
    ngx_int_t                      rc;
    ngx_str_t                     *ct;
    ngx_chain_t                    out;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0, <span style="color: #2aa198;">"image filter"</span>);

    if (in == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx == NULL) {
        return ngx_http_next_body_filter(r, in);
    }

    switch (ctx-&gt;phase) {

    case NGX_HTTP_IMAGE_START:

        ctx-&gt;type = ngx_http_image_test(r, in);

        conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

        if (ctx-&gt;type == NGX_HTTP_IMAGE_NONE) {

            if (conf-&gt;filter == NGX_HTTP_IMAGE_SIZE) {
                out.buf = ngx_http_image_json(r, NULL);

                if (out.buf) {
                    out.next = NULL;
                    ctx-&gt;phase = NGX_HTTP_IMAGE_DONE;

                    return ngx_http_image_send(r, ctx, &amp;out);
                }
            }

            return ngx_http_filter_finalize_request(r,
                                              &amp;ngx_http_image_filter_module,
                                              NGX_HTTP_UNSUPPORTED_MEDIA_TYPE);
        }

        /* override content type */

        ct = &amp;ngx_http_image_types[ctx-&gt;type - 1];
        r-&gt;headers_out.content_type_len = ct-&gt;len;
        r-&gt;headers_out.content_type = *ct;
        r-&gt;headers_out.content_type_lowcase = NULL;

        if (conf-&gt;filter == NGX_HTTP_IMAGE_TEST) {
            ctx-&gt;phase = NGX_HTTP_IMAGE_PASS;

            return ngx_http_image_send(r, ctx, in);
        }

        ctx-&gt;phase = NGX_HTTP_IMAGE_READ;

        /* fall through */

    case NGX_HTTP_IMAGE_READ:

        rc = ngx_http_image_read(r, in);

        if (rc == NGX_AGAIN) {
            return NGX_OK;
        }

        if (rc == NGX_ERROR) {
            return ngx_http_filter_finalize_request(r,
                                              &amp;ngx_http_image_filter_module,
                                              NGX_HTTP_UNSUPPORTED_MEDIA_TYPE);
        }

        /* fall through */

    case NGX_HTTP_IMAGE_PROCESS:

        out.buf = ngx_http_image_process(r);

        if (out.buf == NULL) {
            return ngx_http_filter_finalize_request(r,
                                              &amp;ngx_http_image_filter_module,
                                              NGX_HTTP_UNSUPPORTED_MEDIA_TYPE);
        }

        out.next = NULL;
        ctx-&gt;phase = NGX_HTTP_IMAGE_PASS;

        return ngx_http_image_send(r, ctx, &amp;out);

    case NGX_HTTP_IMAGE_PASS:

        return ngx_http_next_body_filter(r, in);

    default: /* NGX_HTTP_IMAGE_DONE */

        rc = ngx_http_next_body_filter(r, NULL);

        /* NGX_ERROR resets any pending data */
        return (rc == NGX_OK) ? NGX_ERROR : rc;
    }
}


static ngx_int_t
ngx_http_image_send(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx,
    ngx_chain_t *in)
{
    ngx_int_t  rc;

    rc = ngx_http_next_header_filter(r);

    if (rc == NGX_ERROR || rc &gt; NGX_OK || r-&gt;header_only) {
        return NGX_ERROR;
    }

    rc = ngx_http_next_body_filter(r, in);

    if (ctx-&gt;phase == NGX_HTTP_IMAGE_DONE) {
        /* NGX_ERROR resets any pending data */
        return (rc == NGX_OK) ? NGX_ERROR : rc;
    }

    return rc;
}


static ngx_uint_t
ngx_http_image_test(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char  *p;

    p = in-&gt;buf-&gt;pos;

    if (in-&gt;buf-&gt;last - p &lt; 16) {
        return NGX_HTTP_IMAGE_NONE;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                   <span style="color: #2aa198;">"image filter: \"%c%c\""</span>, p[0], p[1]);

    if (p[0] == 0xff &amp;&amp; p[1] == 0xd8) {

        /* JPEG */

        return NGX_HTTP_IMAGE_JPEG;

    } else if (p[0] == 'G' &amp;&amp; p[1] == 'I' &amp;&amp; p[2] == 'F' &amp;&amp; p[3] == '8'
               &amp;&amp; p[5] == 'a')
    {
        if (p[4] == '9' || p[4] == '7') {
            /* GIF */
            return NGX_HTTP_IMAGE_GIF;
        }

    } else if (p[0] == 0x89 &amp;&amp; p[1] == 'P' &amp;&amp; p[2] == 'N' &amp;&amp; p[3] == 'G'
               &amp;&amp; p[4] == 0x0d &amp;&amp; p[5] == 0x0a &amp;&amp; p[6] == 0x1a &amp;&amp; p[7] == 0x0a)
    {
        /* PNG */

        return NGX_HTTP_IMAGE_PNG;
    }

    return NGX_HTTP_IMAGE_NONE;
}


static ngx_int_t
ngx_http_image_read(ngx_http_request_t *r, ngx_chain_t *in)
{
    u_char                       *p;
    size_t                        size, rest;
    ngx_buf_t                    *b;
    ngx_chain_t                  *cl;
    ngx_http_image_filter_ctx_t  *ctx;

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    if (ctx-&gt;image == NULL) {
        ctx-&gt;image = ngx_palloc(r-&gt;pool, ctx-&gt;length);
        if (ctx-&gt;image == NULL) {
            return NGX_ERROR;
        }

        ctx-&gt;last = ctx-&gt;image;
    }

    p = ctx-&gt;last;

    for (cl = in; cl; cl = cl-&gt;next) {

        b = cl-&gt;buf;
        size = b-&gt;last - b-&gt;pos;

        ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                       <span style="color: #2aa198;">"image buf: %uz"</span>, size);

        rest = ctx-&gt;image + ctx-&gt;length - p;
        size = (rest &lt; size) ? rest : size;

        p = ngx_cpymem(p, b-&gt;pos, size);
        b-&gt;pos += size;

        if (b-&gt;last_buf) {
            ctx-&gt;last = p;
            return NGX_OK;
        }
    }

    ctx-&gt;last = p;
    r-&gt;connection-&gt;buffered |= NGX_HTTP_IMAGE_BUFFERED;

    return NGX_AGAIN;
}


static ngx_buf_t *
ngx_http_image_process(ngx_http_request_t *r)
{
    ngx_int_t                      rc;
    ngx_http_image_filter_ctx_t   *ctx;
    ngx_http_image_filter_conf_t  *conf;

    r-&gt;connection-&gt;buffered &amp;= ~NGX_HTTP_IMAGE_BUFFERED;

    ctx = ngx_http_get_module_ctx(r, ngx_http_image_filter_module);

    rc = ngx_http_image_size(r, ctx);

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (conf-&gt;filter == NGX_HTTP_IMAGE_SIZE) {
        return ngx_http_image_json(r, rc == NGX_OK ? ctx : NULL);
    }

    ctx-&gt;angle = ngx_http_image_filter_get_value(r, conf-&gt;acv, conf-&gt;angle);

    if (conf-&gt;filter == NGX_HTTP_IMAGE_ROTATE) {

        if (ctx-&gt;angle != 90 &amp;&amp; ctx-&gt;angle != 180 &amp;&amp; ctx-&gt;angle != 270) {
            return NULL;
        }

        return ngx_http_image_resize(r, ctx);
    }

    if (conf-&gt;filter == NGX_HTTP_IMAGE_WATERMARK) {

        if (!conf-&gt;watermark.data) {
            return NULL;
        }

        return ngx_http_image_resize(r, ctx);
    }    

    ctx-&gt;max_width = ngx_http_image_filter_get_value(r, conf-&gt;wcv, conf-&gt;width);
    if (ctx-&gt;max_width == 0) {
        return NULL;
    }

    ctx-&gt;max_height = ngx_http_image_filter_get_value(r, conf-&gt;hcv,
                                                      conf-&gt;height);
    if (ctx-&gt;max_height == 0) {
        return NULL;
    }

    if (rc == NGX_OK
        &amp;&amp; ctx-&gt;width &lt;= ctx-&gt;max_width
        &amp;&amp; ctx-&gt;height &lt;= ctx-&gt;max_height
        &amp;&amp; ctx-&gt;angle == 0
        &amp;&amp; !ctx-&gt;force)
    {
        return ngx_http_image_asis(r, ctx);
    }

    return ngx_http_image_resize(r, ctx);
}


static ngx_buf_t *
ngx_http_image_json(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    size_t      len;
    ngx_buf_t  *b;

    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
    if (b == NULL) {
        return NULL;
    }

    b-&gt;memory = 1;
    b-&gt;last_buf = 1;

    ngx_http_clean_header(r);

    r-&gt;headers_out.status = NGX_HTTP_OK;
    ngx_str_set(&amp;r-&gt;headers_out.content_type, <span style="color: #2aa198;">"text/plain"</span>);
    r-&gt;headers_out.content_type_lowcase = NULL;

    if (ctx == NULL) {
        b-&gt;pos = (u_char *) <span style="color: #2aa198;">"{}"</span> CRLF;
        b-&gt;last = b-&gt;pos + sizeof(<span style="color: #2aa198;">"{}"</span> CRLF) - 1;

        ngx_http_image_length(r, b);

        return b;
    }

    len = sizeof(<span style="color: #2aa198;">"{ \"img\" : "</span>
                 <span style="color: #2aa198;">"{ \"width\": , \"height\": , \"type\": \"jpeg\" } }"</span> CRLF) - 1
          + 2 * NGX_SIZE_T_LEN;

    b-&gt;pos = ngx_pnalloc(r-&gt;pool, len);
    if (b-&gt;pos == NULL) {
        return NULL;
    }

    b-&gt;last = ngx_sprintf(b-&gt;pos,
                          <span style="color: #2aa198;">"{ \"img\" : "</span>
                                       <span style="color: #2aa198;">"{ \"width\": %uz,"</span>
                                        <span style="color: #2aa198;">" \"height\": %uz,"</span>
                                        <span style="color: #2aa198;">" \"type\": \"%s\" } }"</span> CRLF,
                          ctx-&gt;width, ctx-&gt;height,
                          ngx_http_image_types[ctx-&gt;type - 1].data + 6);

    ngx_http_image_length(r, b);

    return b;
}


static ngx_buf_t *
ngx_http_image_asis(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    ngx_buf_t  *b;

    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
    if (b == NULL) {
        return NULL;
    }

    b-&gt;pos = ctx-&gt;image;
    b-&gt;last = ctx-&gt;last;
    b-&gt;memory = 1;
    b-&gt;last_buf = 1;

    ngx_http_image_length(r, b);

    return b;
}


static void
ngx_http_image_length(ngx_http_request_t *r, ngx_buf_t *b)
{
    r-&gt;headers_out.content_length_n = b-&gt;last - b-&gt;pos;

    if (r-&gt;headers_out.content_length) {
        r-&gt;headers_out.content_length-&gt;hash = 0;
    }

    r-&gt;headers_out.content_length = NULL;
}


static ngx_int_t
ngx_http_image_size(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    u_char      *p, *last;
    size_t       len, app;
    ngx_uint_t   width, height;

    p = ctx-&gt;image;

    switch (ctx-&gt;type) {

    case NGX_HTTP_IMAGE_JPEG:

        p += 2;
        last = ctx-&gt;image + ctx-&gt;length - 10;
        width = 0;
        height = 0;
        app = 0;

        while (p &lt; last) {

            if (p[0] == 0xff &amp;&amp; p[1] != 0xff) {

                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                               <span style="color: #2aa198;">"JPEG: %02xd %02xd"</span>, p[0], p[1]);

                p++;

                if ((*p == 0xc0 || *p == 0xc1 || *p == 0xc2 || *p == 0xc3
                     || *p == 0xc9 || *p == 0xca || *p == 0xcb)
                    &amp;&amp; (width == 0 || height == 0))
                {
                    width = p[6] * 256 + p[7];
                    height = p[4] * 256 + p[5];
                }

                ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                               <span style="color: #2aa198;">"JPEG: %02xd %02xd"</span>, p[1], p[2]);

                len = p[1] * 256 + p[2];

                if (*p &gt;= 0xe1 &amp;&amp; *p &lt;= 0xef) {
                    /* application data, e.g., EXIF, Adobe XMP, etc. */
                    app += len;
                }

                p += len;

                continue;
            }

            p++;
        }

        if (width == 0 || height == 0) {
            return NGX_DECLINED;
        }

        if (ctx-&gt;length / 20 &lt; app) {
            /* force conversion if application data consume more than 5% */
            ctx-&gt;force = 1;
            ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                           <span style="color: #2aa198;">"app data size: %uz"</span>, app);
        }

        break;

    case NGX_HTTP_IMAGE_GIF:

        if (ctx-&gt;length &lt; 10) {
            return NGX_DECLINED;
        }

        width = p[7] * 256 + p[6];
        height = p[9] * 256 + p[8];

        break;

    case NGX_HTTP_IMAGE_PNG:

        if (ctx-&gt;length &lt; 24) {
            return NGX_DECLINED;
        }

        width = p[18] * 256 + p[19];
        height = p[22] * 256 + p[23];

        break;

    default:

        return NGX_DECLINED;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                   <span style="color: #2aa198;">"image size: %d x %d"</span>, width, height);

    ctx-&gt;width = width;
    ctx-&gt;height = height;

    return NGX_OK;
}


static ngx_buf_t *
ngx_http_image_resize(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    int                            sx, sy, dx, dy, ox, oy, ax, ay, size,
                                   colors, palette, transparent, sharpen,
                                   red, green, blue, t;
    u_char                        *out;
    ngx_buf_t                     *b;
    ngx_uint_t                     resize;
    gdImagePtr                     src, dst;
    ngx_pool_cleanup_t            *cln;
    ngx_http_image_filter_conf_t  *conf;

    src = ngx_http_image_source(r, ctx);

    if (src == NULL) {
        return NULL;
    }

    sx = gdImageSX(src);
    sy = gdImageSY(src);

    conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

    if (!ctx-&gt;force
        &amp;&amp; ctx-&gt;angle == 0
        &amp;&amp; (ngx_uint_t) sx &lt;= ctx-&gt;max_width
        &amp;&amp; (ngx_uint_t) sy &lt;= ctx-&gt;max_height)
    {
        gdImageDestroy(src);
        return ngx_http_image_asis(r, ctx);
    }

    colors = gdImageColorsTotal(src);

    if (colors &amp;&amp; conf-&gt;transparency) {
        transparent = gdImageGetTransparent(src);

        if (transparent != -1) {
            palette = colors;
            red = gdImageRed(src, transparent);
            green = gdImageGreen(src, transparent);
            blue = gdImageBlue(src, transparent);

            goto transparent;
        }
    }

    palette = 0;
    transparent = -1;
    red = 0;
    green = 0;
    blue = 0;

transparent:

    gdImageColorTransparent(src, -1);

    dx = sx;
    dy = sy;

    if (conf-&gt;filter == NGX_HTTP_IMAGE_RESIZE) {

        if ((ngx_uint_t) dx &gt; ctx-&gt;max_width) {
            dy = dy * ctx-&gt;max_width / dx;
            dy = dy ? dy : 1;
            dx = ctx-&gt;max_width;
        }

        if ((ngx_uint_t) dy &gt; ctx-&gt;max_height) {
            dx = dx * ctx-&gt;max_height / dy;
            dx = dx ? dx : 1;
            dy = ctx-&gt;max_height;
        }

        resize = 1;

    } else if (conf-&gt;filter == NGX_HTTP_IMAGE_ROTATE) {

        resize = 0;
    } else if (conf-&gt;filter == NGX_HTTP_IMAGE_WATERMARK) {
        
        resize = 0;
    } else { /* NGX_HTTP_IMAGE_CROP */

        resize = 0;

        if ((double) dx / dy &lt; (double) ctx-&gt;max_width / ctx-&gt;max_height) {
            if ((ngx_uint_t) dx &gt; ctx-&gt;max_width) {
                dy = dy * ctx-&gt;max_width / dx;
                dy = dy ? dy : 1;
                dx = ctx-&gt;max_width;
                resize = 1;
            }

        } else {
            if ((ngx_uint_t) dy &gt; ctx-&gt;max_height) {
                dx = dx * ctx-&gt;max_height / dy;
                dx = dx ? dx : 1;
                dy = ctx-&gt;max_height;
                resize = 1;
            }
        }
    }

    if (resize) {
        dst = ngx_http_image_new(r, dx, dy, palette);
        if (dst == NULL) {
            gdImageDestroy(src);
            return NULL;
        }

        if (colors == 0) {
            gdImageSaveAlpha(dst, 1);
            gdImageAlphaBlending(dst, 0);
        }

        gdImageCopyResampled(dst, src, 0, 0, 0, 0, dx, dy, sx, sy);

        if (colors) {
            gdImageTrueColorToPalette(dst, 1, 256);
        }

        gdImageDestroy(src);

    } else {
        dst = src;
    }

    if (ctx-&gt;angle) {
        src = dst;

        ax = (dx % 2 == 0) ? 1 : 0;
        ay = (dy % 2 == 0) ? 1 : 0;

        switch (ctx-&gt;angle) {

        case 90:
        case 270:
            dst = ngx_http_image_new(r, dy, dx, palette);
            if (dst == NULL) {
                gdImageDestroy(src);
                return NULL;
            }
            if (ctx-&gt;angle == 90) {
                ox = dy / 2 + ay;
                oy = dx / 2 - ax;

            } else {
                ox = dy / 2 - ay;
                oy = dx / 2 + ax;
            }

            gdImageCopyRotated(dst, src, ox, oy, 0, 0,
                               dx + ax, dy + ay, ctx-&gt;angle);
            gdImageDestroy(src);

            t = dx;
            dx = dy;
            dy = t;
            break;

        case 180:
            dst = ngx_http_image_new(r, dx, dy, palette);
            if (dst == NULL) {
                gdImageDestroy(src);
                return NULL;
            }
            gdImageCopyRotated(dst, src, dx / 2 - ax, dy / 2 - ay, 0, 0,
                               dx + ax, dy + ay, ctx-&gt;angle);
            gdImageDestroy(src);
            break;
        }
    }

    if (conf-&gt;filter == NGX_HTTP_IMAGE_CROP) {

        src = dst;

        if ((ngx_uint_t) dx &gt; ctx-&gt;max_width) {
            ox = dx - ctx-&gt;max_width;

        } else {
            ox = 0;
        }

        if ((ngx_uint_t) dy &gt; ctx-&gt;max_height) {
            oy = dy - ctx-&gt;max_height;

        } else {
            oy = 0;
        }

        if (ox || oy) {

            dst = ngx_http_image_new(r, dx - ox, dy - oy, colors);

            if (dst == NULL) {
                gdImageDestroy(src);
                return NULL;
            }

            ox /= 2;
            oy /= 2;

            ngx_log_debug4(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                           <span style="color: #2aa198;">"image crop: %d x %d @ %d x %d"</span>,
                           dx, dy, ox, oy);

            if (colors == 0) {
                gdImageSaveAlpha(dst, 1);
                gdImageAlphaBlending(dst, 0);
            }

            gdImageCopy(dst, src, 0, 0, ox, oy, dx - ox, dy - oy);

            if (colors) {
                gdImageTrueColorToPalette(dst, 1, 256);
            }

            gdImageDestroy(src);
        }
    }

    if (transparent != -1 &amp;&amp; colors) {
        gdImageColorTransparent(dst, gdImageColorExact(dst, red, green, blue));
    }

    if (conf-&gt;filter == NGX_HTTP_IMAGE_WATERMARK &amp;&amp; conf-&gt;watermark.data) {
        FILE *watermark_file = fopen((const char *)conf-&gt;watermark.data, <span style="color: #2aa198;">"r"</span>);
        if (watermark_file) {
            gdImagePtr watermark, watermark_mix;
            ngx_int_t wdx = 0, wdy = 0;
            
            watermark = gdImageCreateFromPng(watermark_file);
                
            if(watermark != NULL) {
                watermark_mix = gdImageCreateTrueColor(watermark-&gt;sx, watermark-&gt;sy);
                wdx = dx/2 - watermark-&gt;sx/2;
                wdy = dy/2 - watermark-&gt;sy/2;
                gdImageCopy(watermark_mix, dst, 0, 0, wdx, wdy, watermark-&gt;sx, watermark-&gt;sy);
                gdImageCopy(watermark_mix, watermark, 0, 0, 0, 0, watermark-&gt;sx, watermark-&gt;sy);
                gdImageCopyMerge(dst, watermark_mix, wdx, wdy, 0, 0, watermark-&gt;sx, watermark-&gt;sy, conf-&gt;watermark_transparency);
                gdFree(watermark);
                gdFree(watermark_mix);
            } else { ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, <span style="color: #2aa198;">"watermark file '%s' is not PNG"</span>, conf-&gt;watermark.data);}
        } else {
            ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, <span style="color: #2aa198;">"watermark file '%s' not found"</span>, conf-&gt;watermark.data);
        }
    }
    
    sharpen = ngx_http_image_filter_get_value(r, conf-&gt;shcv, conf-&gt;sharpen);
    if (sharpen &gt; 0) {
        gdImageSharpen(dst, sharpen);
    }

    out = ngx_http_image_out(r, ctx-&gt;type, dst, &amp;size);

    ngx_log_debug3(NGX_LOG_DEBUG_HTTP, r-&gt;connection-&gt;log, 0,
                   <span style="color: #2aa198;">"image: %d x %d %d"</span>, sx, sy, colors);

    gdImageDestroy(dst);
    ngx_pfree(r-&gt;pool, ctx-&gt;image);

    if (out == NULL) {
        return NULL;
    }

    cln = ngx_pool_cleanup_add(r-&gt;pool, 0);
    if (cln == NULL) {
        gdFree(out);
        return NULL;
    }

    b = ngx_pcalloc(r-&gt;pool, sizeof(ngx_buf_t));
    if (b == NULL) {
        gdFree(out);
        return NULL;
    }

    cln-&gt;handler = ngx_http_image_cleanup;
    cln-&gt;data = out;

    b-&gt;pos = out;
    b-&gt;last = out + size;
    b-&gt;memory = 1;
    b-&gt;last_buf = 1;

    ngx_http_image_length(r, b);

    return b;
}


static gdImagePtr
ngx_http_image_source(ngx_http_request_t *r, ngx_http_image_filter_ctx_t *ctx)
{
    char        *failed;
    gdImagePtr   img;

    img = NULL;

    switch (ctx-&gt;type) {

    case NGX_HTTP_IMAGE_JPEG:
        img = gdImageCreateFromJpegPtr(ctx-&gt;length, ctx-&gt;image);
        failed = <span style="color: #2aa198;">"gdImageCreateFromJpegPtr() failed"</span>;
        break;

    case NGX_HTTP_IMAGE_GIF:
        img = gdImageCreateFromGifPtr(ctx-&gt;length, ctx-&gt;image);
        failed = <span style="color: #2aa198;">"gdImageCreateFromGifPtr() failed"</span>;
        break;

    case NGX_HTTP_IMAGE_PNG:
        img = gdImageCreateFromPngPtr(ctx-&gt;length, ctx-&gt;image);
        failed = <span style="color: #2aa198;">"gdImageCreateFromPngPtr() failed"</span>;
        break;

    default:
        failed = <span style="color: #2aa198;">"unknown image type"</span>;
        break;
    }

    if (img == NULL) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, failed);
    }

    return img;
}


static gdImagePtr
ngx_http_image_new(ngx_http_request_t *r, int w, int h, int colors)
{
    gdImagePtr  img;

    if (colors == 0) {
        img = gdImageCreateTrueColor(w, h);

        if (img == NULL) {
            ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                          <span style="color: #2aa198;">"gdImageCreateTrueColor() failed"</span>);
            return NULL;
        }

    } else {
        img = gdImageCreate(w, h);

        if (img == NULL) {
            ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0,
                          <span style="color: #2aa198;">"gdImageCreate() failed"</span>);
            return NULL;
        }
    }

    return img;
}


static u_char *
ngx_http_image_out(ngx_http_request_t *r, ngx_uint_t type, gdImagePtr img,
    int *size)
{
    char                          *failed;
    u_char                        *out;
    ngx_int_t                      jq;
    ngx_http_image_filter_conf_t  *conf;

    out = NULL;

    switch (type) {

    case NGX_HTTP_IMAGE_JPEG:
        conf = ngx_http_get_module_loc_conf(r, ngx_http_image_filter_module);

        jq = ngx_http_image_filter_get_value(r, conf-&gt;jqcv, conf-&gt;jpeg_quality);
        if (jq &lt;= 0) {
            return NULL;
        }

        out = gdImageJpegPtr(img, size, jq);
        failed = <span style="color: #2aa198;">"gdImageJpegPtr() failed"</span>;
        break;

    case NGX_HTTP_IMAGE_GIF:
        out = gdImageGifPtr(img, size);
        failed = <span style="color: #2aa198;">"gdImageGifPtr() failed"</span>;
        break;

    case NGX_HTTP_IMAGE_PNG:
        out = gdImagePngPtr(img, size);
        failed = <span style="color: #2aa198;">"gdImagePngPtr() failed"</span>;
        break;

    default:
        failed = <span style="color: #2aa198;">"unknown image type"</span>;
        break;
    }

    if (out == NULL) {
        ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;log, 0, failed);
    }

    return out;
}


static void
ngx_http_image_cleanup(void *data)
{
    gdFree(data);
}


static ngx_uint_t
ngx_http_image_filter_get_value(ngx_http_request_t *r,
    ngx_http_complex_value_t *cv, ngx_uint_t v)
{
    ngx_str_t  val;

    if (cv == NULL) {
        return v;
    }

    if (ngx_http_complex_value(r, cv, &amp;val) != NGX_OK) {
        return 0;
    }

    return ngx_http_image_filter_value(&amp;val);
}


static ngx_uint_t
ngx_http_image_filter_value(ngx_str_t *value)
{
    ngx_int_t  n;

    if (value-&gt;len == 1 &amp;&amp; value-&gt;data[0] == '-') {
        return (ngx_uint_t) -1;
    }

    n = ngx_atoi(value-&gt;data, value-&gt;len);

    if (n &gt; 0) {
        return (ngx_uint_t) n;
    }

    return 0;
}


static void *
ngx_http_image_filter_create_conf(ngx_conf_t *cf)
{
    ngx_http_image_filter_conf_t  *conf;

    conf = ngx_pcalloc(cf-&gt;pool, sizeof(ngx_http_image_filter_conf_t));
    if (conf == NULL) {
        return NULL;
    }

    /*
     * set by ngx_pcalloc():
     *
     *     conf-&gt;width = 0;
     *     conf-&gt;height = 0;
     *     conf-&gt;angle = 0;
     *     conf-&gt;wcv = NULL;
     *     conf-&gt;hcv = NULL;
     *     conf-&gt;acv = NULL;
     *     conf-&gt;jqcv = NULL;
     *     conf-&gt;shcv = NULL;
     */

    conf-&gt;filter = NGX_CONF_UNSET_UINT;
    conf-&gt;jpeg_quality = NGX_CONF_UNSET_UINT;
    conf-&gt;sharpen = NGX_CONF_UNSET_UINT;
    conf-&gt;transparency = NGX_CONF_UNSET;
    conf-&gt;buffer_size = NGX_CONF_UNSET_SIZE;
    conf-&gt;watermark_transparency = NGX_CONF_UNSET_UINT;

    return conf;
}


static char *
ngx_http_image_filter_merge_conf(ngx_conf_t *cf, void *parent, void *child)
{
    ngx_http_image_filter_conf_t *prev = parent;
    ngx_http_image_filter_conf_t *conf = child;

    if (conf-&gt;filter == NGX_CONF_UNSET_UINT) {

        if (prev-&gt;filter == NGX_CONF_UNSET_UINT) {
            conf-&gt;filter = NGX_HTTP_IMAGE_OFF;

        } else {
            conf-&gt;filter = prev-&gt;filter;
            conf-&gt;width = prev-&gt;width;
            conf-&gt;height = prev-&gt;height;
            conf-&gt;angle = prev-&gt;angle;
            conf-&gt;wcv = prev-&gt;wcv;
            conf-&gt;hcv = prev-&gt;hcv;
            conf-&gt;acv = prev-&gt;acv;
        }
    }

    if (conf-&gt;jpeg_quality == NGX_CONF_UNSET_UINT) {

        /* 75 is libjpeg default quality */
        ngx_conf_merge_uint_value(conf-&gt;jpeg_quality, prev-&gt;jpeg_quality, 75);

        if (conf-&gt;jqcv == NULL) {
            conf-&gt;jqcv = prev-&gt;jqcv;
        }
    }

    if (conf-&gt;sharpen == NGX_CONF_UNSET_UINT) {
        ngx_conf_merge_uint_value(conf-&gt;sharpen, prev-&gt;sharpen, 0);

        if (conf-&gt;shcv == NULL) {
            conf-&gt;shcv = prev-&gt;shcv;
        }
    }

    ngx_conf_merge_value(conf-&gt;transparency, prev-&gt;transparency, 1);

    ngx_conf_merge_size_value(conf-&gt;buffer_size, prev-&gt;buffer_size,
                              1 * 1024 * 1024);

    ngx_conf_merge_str_value(conf-&gt;watermark, prev-&gt;watermark, <span style="color: #2aa198;">""</span>);

    ngx_conf_merge_uint_value(conf-&gt;watermark_transparency,
                              prev-&gt;watermark_transparency, 90);
    
    return NGX_CONF_OK;
}


static char *
ngx_http_image_filter(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_uint_t                         i;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf-&gt;args-&gt;elts;

    i = 1;

    if (cf-&gt;args-&gt;nelts == 2) {
        if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"off"</span>) == 0) {
            imcf-&gt;filter = NGX_HTTP_IMAGE_OFF;

        } else if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"test"</span>) == 0) {
            imcf-&gt;filter = NGX_HTTP_IMAGE_TEST;

        } else if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"size"</span>) == 0) {
            imcf-&gt;filter = NGX_HTTP_IMAGE_SIZE;

        } else if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"watermark"</span>) == 0) {
            imcf-&gt;filter = NGX_HTTP_IMAGE_WATERMARK;
            
        } else {
            goto failed;
        }

        return NGX_CONF_OK;

    } else if (cf-&gt;args-&gt;nelts == 3) {

        if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"rotate"</span>) == 0) {
            if (imcf-&gt;filter != NGX_HTTP_IMAGE_RESIZE
                &amp;&amp; imcf-&gt;filter != NGX_HTTP_IMAGE_CROP)
            {
                imcf-&gt;filter = NGX_HTTP_IMAGE_ROTATE;
            }

            ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

            ccv.cf = cf;
            ccv.value = &amp;value[++i];
            ccv.complex_value = &amp;cv;

            if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
                return NGX_CONF_ERROR;
            }

            if (cv.lengths == NULL) {
                n = ngx_http_image_filter_value(&amp;value[i]);

                if (n != 90 &amp;&amp; n != 180 &amp;&amp; n != 270) {
                    goto failed;
                }

                imcf-&gt;angle = (ngx_uint_t) n;

            } else {
                imcf-&gt;acv = ngx_palloc(cf-&gt;pool,
                                       sizeof(ngx_http_complex_value_t));
                if (imcf-&gt;acv == NULL) {
                    return NGX_CONF_ERROR;
                }

                *imcf-&gt;acv = cv;
            }

            return NGX_CONF_OK;

        } else {
            goto failed;
        }
    }

    if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"resize"</span>) == 0) {
        imcf-&gt;filter = NGX_HTTP_IMAGE_RESIZE;

    } else if (ngx_strcmp(value[i].data, <span style="color: #2aa198;">"crop"</span>) == 0) {
        imcf-&gt;filter = NGX_HTTP_IMAGE_CROP;

    } else {
        goto failed;
    }

    ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &amp;value[++i];
    ccv.complex_value = &amp;cv;

    if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&amp;value[i]);

        if (n == 0) {
            goto failed;
        }

        imcf-&gt;width = (ngx_uint_t) n;

    } else {
        imcf-&gt;wcv = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t));
        if (imcf-&gt;wcv == NULL) {
            return NGX_CONF_ERROR;
        }

        *imcf-&gt;wcv = cv;
    }

    ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &amp;value[++i];
    ccv.complex_value = &amp;cv;

    if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&amp;value[i]);

        if (n == 0) {
            goto failed;
        }

        imcf-&gt;height = (ngx_uint_t) n;

    } else {
        imcf-&gt;hcv = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t));
        if (imcf-&gt;hcv == NULL) {
            return NGX_CONF_ERROR;
        }

        *imcf-&gt;hcv = cv;
    }

    return NGX_CONF_OK;

failed:

    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0, <span style="color: #2aa198;">"invalid parameter \"%V\""</span>,
                       &amp;value[i]);

    return NGX_CONF_ERROR;
}


static char *
ngx_http_image_filter_jpeg_quality(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf-&gt;args-&gt;elts;

    ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &amp;value[1];
    ccv.complex_value = &amp;cv;

    if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&amp;value[1]);

        if (n &lt;= 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               <span style="color: #2aa198;">"invalid value \"%V\""</span>, &amp;value[1]);
            return NGX_CONF_ERROR;
        }

        imcf-&gt;jpeg_quality = (ngx_uint_t) n;

    } else {
        imcf-&gt;jqcv = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t));
        if (imcf-&gt;jqcv == NULL) {
            return NGX_CONF_ERROR;
        }

        *imcf-&gt;jqcv = cv;
    }

    return NGX_CONF_OK;
}


static char *
ngx_http_image_filter_sharpen(ngx_conf_t *cf, ngx_command_t *cmd,
    void *conf)
{
    ngx_http_image_filter_conf_t *imcf = conf;

    ngx_str_t                         *value;
    ngx_int_t                          n;
    ngx_http_complex_value_t           cv;
    ngx_http_compile_complex_value_t   ccv;

    value = cf-&gt;args-&gt;elts;

    ngx_memzero(&amp;ccv, sizeof(ngx_http_compile_complex_value_t));

    ccv.cf = cf;
    ccv.value = &amp;value[1];
    ccv.complex_value = &amp;cv;

    if (ngx_http_compile_complex_value(&amp;ccv) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (cv.lengths == NULL) {
        n = ngx_http_image_filter_value(&amp;value[1]);

        if (n &lt; 0) {
            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
                               <span style="color: #2aa198;">"invalid value \"%V\""</span>, &amp;value[1]);
            return NGX_CONF_ERROR;
        }

        imcf-&gt;sharpen = (ngx_uint_t) n;

    } else {
        imcf-&gt;shcv = ngx_palloc(cf-&gt;pool, sizeof(ngx_http_complex_value_t));
        if (imcf-&gt;shcv == NULL) {
            return NGX_CONF_ERROR;
        }

        *imcf-&gt;shcv = cv;
    }

    return NGX_CONF_OK;
}


static ngx_int_t
ngx_http_image_filter_init(ngx_conf_t *cf)
{
    ngx_http_next_header_filter = ngx_http_top_header_filter;
    ngx_http_top_header_filter = ngx_http_image_header_filter;

    ngx_http_next_body_filter = ngx_http_top_body_filter;
    ngx_http_top_body_filter = ngx_http_image_body_filter;

    return NGX_OK;
}
</pre></div></div>


</div>

</div>

<div id="outline-container-3-3" class="outline-4">
<h4 id="sec-3-3">编译</h4>
<div class="outline-text-4" id="text-3-3">




<pre class="src src-sh">--with-debug --with-http_image_filter_module --add-module=/home/tangxinfa/Opensource/nginx-1.2.7/../ngx_http_qrcode_module/ --add-module=/home/tangxinfa/Opensource/nginx-1.2.7/../ngx_devel_kit/ --add-module=/home/tangxinfa/Opensource/nginx-1.2.7/../set-misc-nginx-module/ --add-module=/home/tangxinfa/Opensource/nginx-1.2.7/../echo-nginx-module/
</pre>


</div>

</div>

<div id="outline-container-3-4" class="outline-4">
<h4 id="sec-3-4">配置</h4>
<div class="outline-text-4" id="text-3-4">




<pre class="example">location ~ /qr {
    qrcode_fg_color FF0000;
    qrcode_bg_color FFFFFF;    
    qrcode_level 2;
    qrcode_hint 2;
    qrcode_size 120;
    qrcode_margin 2;
    qrcode_version 5;
    set_unescape_uri $txt $arg_txt;
    qrcode_txt $txt;
    qrcode_casesensitive 1; 
    qrcode_gen;  

    image_filter_watermark "/usr/share/pixmaps/gnome-word.png";
    image_filter_watermark_transparency 95; #0-100
    image_filter watermark;
}
</pre>


</div>

</div>

<div id="outline-container-3-5" class="outline-4">
<h4 id="sec-3-5">访问</h4>
<div class="outline-text-4" id="text-3-5">




<pre class="example">http://localhost:8080/qr?txt=hello
</pre>

<ul>
<li>显示效果：
</li>
</ul>

<p>     <img src="../../../posts/2013/03/30_4e8c7ef4780178147a76/hello_qr.png"  alt="../../../posts/2013/03/30_4e8c7ef4780178147a76/hello_qr.png" />
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-3">
<h3 id="sec-4">二维码基础服务的一点思索</h3>
<div class="outline-text-3" id="text-4">

<ul>
<li>必须建立在cdn的基础上
</li>
<li>用户只需按照约定将内容以及定制参数按照直观的方式编码成二维码图片链接即可
</li>
</ul>


<p>
   参考：<a href="https://developers.google.com/chart/infographics/docs/qr_codes">https://developers.google.com/chart/infographics/docs/qr_codes</a>
</p></div>
</div>

  </div>
  
  <footer class="article-footer">
    <nav class="tag-cloud">
      <ul>
	<li class="label label-inverse small"><a href="../../../tags/qrcode.html">qrcode</a></li>
      </ul>
    </nav>
    <span class="muted">
      发布于 <time datetime="2013-03-30T11:21:00Z"> 2013-03-30 11:21:00</time>
    </span>
  </footer>
  </div>
  <div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'kankananblog'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

      </div>
      <div id="footer">
	<div class="container">
	  <div class="row">
	    <nav class="span3">
	      <h1>关于</h1>
	      <p>
记我所思，忆我所为
</p>
	    </nav>
	    <nav id="links" class="span3">
	      <h1>链接</h1>
	      <ul>
		<ul>
<li><a href="../../../index.html"><i>icon-home icon-white</i> 首页</a>

</li>
<li><a href="../../../tags.html"><i>icon-tags icon-white</i> 标签</a>

</li>
<li><a href="../../../archives.html"><i>icon-list icon-white</i> 归档</a>

</li>
<li><a href="../../../index.xml"><i>icon-rss icon-white</i> 订阅</a>

</li>
<li><a href="../../../changelog.html"><i>icon-pencil icon-white</i> 更新日志</a>
</li>
</ul>



	      </ul>
	    </nav>
	    <nav id="archives" class="span3">
	      <h1><a href="../../../archives.html">归档</a></h1>
	      <ul>
		<li><a href="../../../index.html">使用o-blog搭建个人博客</a></li> <li><a href="../../../posts/2013/04/07_59824f555b664e6082f18bed.html">如何学习英语</a></li> <li><a href="../../../posts/2013/03/30_5728emacs4e2d59824f554ee5root674396504f7f7528gdb8c038bd57a0b5e8f.html">在emacs中如何以root权限使用gdb调试程序</a></li> <li><a href="../../../posts/2013/03/30_4e8c7ef4780178147a76.html">二维码研究</a></li> <li><a href="../../../posts/2013/03/27_archlinux4e0b5b8988c5cups625353707cfb7edf.html">Archlinux下安装cups打印系统</a></li> <li><a href="../../../posts/2013/03/20_python4e2d7684utc4e0e672c573065f6533a59047406.html">python中的UTC与本地时区处理</a></li> <li><a href="../../../posts/2013/03/15_c2b2b768451fd6570300195ed53054e0e534f7a0b.html">C++的函数、闭包与协程</a></li> <li><a href="../../../posts/2013/03/10_7f5198754e2d768481ea52a85b8c621076844e0b62c9521788686846.html">网页中的自动完成的下拉列表框</a></li> <li><a href="../../../posts/2013/03/09_linux4e0b8de88fdb7a0b4f20901265874ef663cf8ff07b26.html">linux下跨进程传递文件描述符</a></li> <li><a href="../../../posts/2013/02/28_web6a21578b521d63a2.html">Web模型初探</a></li> 
	      </ul>
	    </nav>
	    <nav class="tags span3">
	      <h1><a href="../../../tags/index.html">标签</a></h1>
	      <ul>
  <li style="font-size: 173.33%;"><a href="../../../tags/archlinux.html">archlinux</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/chosen.html">chosen</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/comet.html">comet</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/cpp.html">cpp</a></li> <li style="font-size: 126.67%;"><a href="../../../tags/emacs.html">emacs</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/english.html">english</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/fcitx.html">fcitx</a></li> <li style="font-size: 126.67%;"><a href="../../../tags/hash.html">hash</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/http.html">http</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/jquery.html">jquery</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/linux.html">linux</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/memcached.html">memcached</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/mongodb.html">mongodb</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/mysql.html">mysql</a></li> <li style="font-size: 173.33%;"><a href="../../../tags/nginx.html">nginx</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/o-blog.html">o-blog</a></li> <li style="font-size: 173.33%;"><a href="../../../tags/php.html">php</a></li> <li style="font-size: 126.67%;"><a href="../../../tags/python.html">python</a></li> <li style="font-size: 80.00%;"><a href="../../../tags/qrcode.html">qrcode</a></li> <li style="font-size: 220.00%;"><a href="../../../tags/redis.html">redis</a></li> <li style="font-size: 173.33%;"><a href="../../../tags/web.html">web</a></li> 
</ul>

	    </nav>
	  </div>
	</div>
	<div class="copyright" style="text-align: center;">
	  <p>
版权所有 © 2011-2013 看看俺 – KanKanAn.com
</p>
	  <p>Powered by <a href="https://github.com/renard/o-blog">o-blog</a>.</p>
	</div>
      </div>
</body>
</html>

